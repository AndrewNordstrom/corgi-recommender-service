============================= test session starts ==============================
platform darwin -- Python 3.12.1, pytest-8.3.5, pluggy-1.5.0 -- /Library/Frameworks/Python.framework/Versions/3.12/bin/python3.12
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/.hypothesis/examples'))
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service
configfile: pytest.ini
plugins: env-0.8.1, hypothesis-6.130.2, dash-3.0.0, cov-4.1.0, anyio-4.4.0, benchmark-5.1.0, asyncio-0.26.0, langsmith-0.3.19, mock-3.14.0, xdist-3.6.1
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 426 items

tests/config_tests/test_cli_args.py::TestPortValidation::test_custom_default PASSED [  0%]
tests/config_tests/test_cli_args.py::TestPortValidation::test_invalid_port PASSED [  0%]
tests/config_tests/test_cli_args.py::TestPortValidation::test_valid_port PASSED [  0%]
tests/config_tests/test_cli_args.py::TestServerArgParsing::test_cert_path_override PASSED [  0%]
tests/config_tests/test_cli_args.py::TestServerArgParsing::test_force_http_flag PASSED [  1%]
tests/config_tests/test_cli_args.py::TestServerArgParsing::test_host_override PASSED [  1%]
tests/config_tests/test_cli_args.py::TestServerArgParsing::test_key_path_override PASSED [  1%]
tests/config_tests/test_cli_args.py::TestServerArgParsing::test_no_https_flag PASSED [  1%]
tests/config_tests/test_cli_args.py::TestServerArgParsing::test_port_override PASSED [  2%]
tests/config_tests/test_cli_args.py::TestProxyArgParsing::test_host_override PASSED [  2%]
tests/config_tests/test_cli_args.py::TestProxyArgParsing::test_port_override PASSED [  2%]
tests/config_tests/test_cli_args.py::TestSpecialProxyArgParsing::test_host_override PASSED [  2%]
tests/config_tests/test_cli_args.py::TestSpecialProxyArgParsing::test_port_override PASSED [  3%]
tests/test_ab_analysis.py::test_automated_analysis PASSED                [  3%]
tests/test_ab_analysis.py::test_api_endpoints PASSED                     [  3%]
tests/test_ab_performance.py::test_real_time_performance PASSED          [  3%]
tests/test_ab_performance.py::test_performance_comparison PASSED         [  3%]
tests/test_ab_performance.py::test_prometheus_metrics PASSED             [  4%]
tests/test_agent_features.py::test_token_tracking PASSED                 [  4%]
tests/test_agent_features.py::test_browser_agent_no_llm PASSED           [  4%]
tests/test_agent_features.py::test_browser_agent_with_tools SKIPPED      [  4%]
tests/test_agent_features.py::test_batch_processing PASSED               [  5%]
tests/test_agent_features.py::test_interaction_limits SKIPPED (Claude
API not available in test environment)                                   [  5%]
tests/test_all_features.py::test_token_tracking PASSED                   [  5%]
tests/test_all_features.py::test_browser_agent_no_llm PASSED             [  5%]
tests/test_all_features.py::test_browser_agent_with_tools SKIPPED        [  6%]
tests/test_all_features.py::test_batch_processing PASSED                 [  6%]
tests/test_all_features.py::test_interaction_limits SKIPPED (Claude API
not available in test environment)                                       [  6%]
tests/test_api_caching.py::TestAPICaching::test_health_endpoint_caching PASSED [  6%]
tests/test_api_caching.py::TestAPICaching::test_api_docs_spec_caching PASSED [  7%]
tests/test_api_caching.py::TestAPICaching::test_profile_requests_caching PASSED [  7%]
tests/test_api_caching.py::TestAPICaching::test_proxy_status_caching PASSED [  7%]
tests/test_api_caching.py::TestAPICaching::test_timeline_caching PASSED  [  7%]
tests/test_api_caching.py::TestAPICaching::test_cache_invalidation PASSED [  7%]
tests/test_api_flow.py::test_user_authentication_flow PASSED             [  8%]
tests/test_api_flow.py::test_timeline_flow PASSED                        [  8%]
tests/test_api_flow.py::test_user_interaction_flow PASSED                [  8%]
tests/test_api_flow.py::test_privacy_settings_flow PASSED                [  8%]
tests/test_api_flow.py::test_error_handling_flow PASSED                  [  9%]
tests/test_api_flow.py::test_complete_user_journey PASSED                [  9%]
tests/test_api_recommendations_timeline.py::test_recommendations_timeline_endpoint FAILED [  9%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_recommendations_sync_fallback FAILED [  9%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_recommendations_parameters_validation FAILED [ 10%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_async_task_queuing FAILED [ 10%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_status_endpoint FAILED [ 10%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_status_pending FAILED [ 10%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_status_failure FAILED [ 11%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_cancellation FAILED [ 11%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_cancel_completed FAILED [ 11%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_async_unavailable_fallback FAILED [ 11%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_hybrid_cache_behavior FAILED [ 11%]
tests/test_async_recommendations.py::TestAsyncRecommendations::test_processing_time_tracking FAILED [ 12%]
tests/test_async_recommendations.py::TestAsyncIntegration::test_end_to_end_async_flow FAILED [ 12%]
tests/test_async_recommendations.py::TestAsyncIntegration::test_backwards_compatibility PASSED [ 12%]
tests/test_authentication.py::TestBasicAuthentication::test_validate_valid_token PASSED [ 12%]
tests/test_authentication.py::TestBasicAuthentication::test_validate_invalid_token PASSED [ 13%]
tests/test_authentication.py::TestBasicAuthentication::test_validate_empty_token PASSED [ 13%]
tests/test_authentication.py::TestBasicAuthentication::test_get_user_from_valid_token PASSED [ 13%]
tests/test_authentication.py::TestBasicAuthentication::test_get_user_from_invalid_token PASSED [ 13%]
tests/test_authentication.py::TestTokenManagement::test_token_expiration_check PASSED [ 14%]
tests/test_authentication.py::TestTokenManagement::test_token_refresh_success PASSED [ 14%]
tests/test_authentication.py::TestTokenManagement::test_token_refresh_failure PASSED [ 14%]
tests/test_authentication.py::TestTokenManagement::test_token_refresh_empty_token PASSED [ 14%]
tests/test_authentication.py::TestTokenManagement::test_token_refresh_network_error PASSED [ 15%]
tests/test_authentication.py::TestOAuthFlow::test_oauth_authorization_url_generation PASSED [ 15%]
tests/test_authentication.py::TestOAuthFlow::test_oauth_token_exchange_success PASSED [ 15%]
tests/test_authentication.py::TestOAuthFlow::test_oauth_token_exchange_failure PASSED [ 15%]
tests/test_authentication.py::TestOAuthFlow::test_oauth_scope_validation PASSED [ 15%]
tests/test_authentication.py::TestTokenRefreshFlow::test_refresh_token_success PASSED [ 16%]
tests/test_authentication.py::TestTokenRefreshFlow::test_refresh_token_expired PASSED [ 16%]
tests/test_authentication.py::TestTokenRefreshFlow::test_refresh_token_storage_update PASSED [ 16%]
tests/test_authentication.py::TestAuthenticationIntegration::test_full_oauth_flow_simulation PASSED [ 16%]
tests/test_authentication.py::TestAuthenticationIntegration::test_token_lifecycle_management PASSED [ 17%]
tests/test_authentication.py::TestAuthenticationIntegration::test_authentication_error_handling PASSED [ 17%]
tests/test_authentication.py::TestAuthenticationSecurity::test_token_sanitization PASSED [ 17%]
tests/test_authentication.py::TestAuthenticationSecurity::test_secure_token_storage PASSED [ 17%]
tests/test_authentication.py::TestAuthenticationSecurity::test_token_scope_enforcement PASSED [ 18%]
tests/test_caching_system.py::TestRedisClient::test_get_redis_client PASSED [ 18%]
tests/test_caching_system.py::TestRedisClient::test_redis_connection_error PASSED [ 18%]
tests/test_caching_system.py::TestRedisClient::test_redis_disabled PASSED [ 18%]
tests/test_caching_system.py::TestCacheOperations::test_cache_key_format PASSED [ 19%]
tests/test_caching_system.py::TestCacheOperations::test_cache_get_set_delete PASSED [ 19%]
tests/test_caching_system.py::TestCacheOperations::test_cache_set_non_serializable PASSED [ 19%]
tests/test_caching_system.py::TestCacheOperations::test_clear_cache PASSED [ 19%]
tests/test_caching_system.py::TestRecommendationCache::test_cache_recommendations PASSED [ 19%]
tests/test_caching_system.py::TestRecommendationCache::test_get_cached_recommendations PASSED [ 20%]
tests/test_caching_system.py::TestRecommendationCache::test_invalidate_user_recommendations PASSED [ 20%]
tests/test_caching_system.py::TestTimelineCache::test_timeline_cache_key_generation PASSED [ 20%]
tests/test_caching_system.py::TestTimelineCache::test_cache_timeline_data PASSED [ 20%]
tests/test_caching_system.py::TestCacheIntegration::test_cache_performance_under_load PASSED [ 21%]
tests/test_caching_system.py::TestCacheIntegration::test_cache_key_collision_prevention PASSED [ 21%]
tests/test_caching_system.py::TestCacheIntegration::test_cache_error_recovery PASSED [ 21%]
tests/test_caching_system.py::TestCacheDisabled::test_cache_operations_when_disabled PASSED [ 21%]
tests/test_caching_system.py::TestCacheDisabled::test_recommendation_cache_when_disabled PASSED [ 22%]
tests/test_celery_integration.py::test_celery_integration PASSED         [ 22%]
tests/test_connection_pool.py::test_connection_health PASSED             [ 22%]
tests/test_connection_pool.py::TestEnhancedConnectionPool::test_connection_pool_initialization SKIPPED [ 22%]
tests/test_connection_pool.py::TestEnhancedConnectionPool::test_get_connection SKIPPED [ 23%]
tests/test_connection_pool.py::TestEnhancedConnectionPool::test_connection_reuse SKIPPED [ 23%]
tests/test_connection_pool.py::TestEnhancedConnectionPool::test_connection_close SKIPPED [ 23%]
tests/test_connection_pool.py::TestEnhancedConnectionPool::test_test_connection SKIPPED [ 23%]
tests/test_connection_pool.py::TestEnhancedConnectionPool::test_get_stats SKIPPED [ 23%]
tests/test_connection_pool.py::TestEnhancedConnectionPool::test_recreate_pool SKIPPED [ 24%]
tests/test_connection_pool.py::TestGlobalPoolFunctions::test_initialize_connection_pool SKIPPED [ 24%]
tests/test_connection_pool.py::TestGlobalPoolFunctions::test_get_pg_connection SKIPPED [ 24%]
tests/test_connection_pool.py::TestGlobalPoolFunctions::test_get_pool_stats SKIPPED [ 24%]
tests/test_connection_pool.py::TestGlobalPoolFunctions::test_close_connection_pool SKIPPED [ 25%]
tests/test_content_crawler.py::TestLanguageDetector::test_detect_language_edge_cases PASSED [ 25%]
tests/test_content_crawler.py::TestLanguageDetector::test_detect_language_english PASSED [ 25%]
tests/test_content_crawler.py::TestLanguageDetector::test_detect_language_non_english PASSED [ 25%]
tests/test_content_crawler.py::TestLanguageDetector::test_supported_languages PASSED [ 26%]
tests/test_content_crawler.py::TestMastodonAPIClient::test_get_public_timeline_success PASSED [ 26%]
tests/test_content_crawler.py::TestMastodonAPIClient::test_get_trending_hashtags PASSED [ 26%]
tests/test_content_crawler.py::TestMastodonAPIClient::test_rate_limit_handling PASSED [ 26%]
tests/test_content_crawler.py::TestContentCrawlerTasks::test_aggregate_trending_posts PASSED [ 26%]
tests/test_content_crawler.py::TestContentCrawlerTasks::test_crawl_instance_timeline_success PASSED [ 27%]
tests/test_content_crawler.py::TestContentCrawlerTasks::test_update_post_lifecycle PASSED [ 27%]
tests/test_content_crawler.py::TestContentDiscoveryAPI::test_get_crawler_status PASSED [ 27%]
tests/test_content_crawler.py::TestContentDiscoveryAPI::test_get_discovery_stats PASSED [ 27%]
tests/test_content_crawler.py::TestColdStartIntegration::test_get_dynamic_cold_start_posts_success PASSED [ 28%]
tests/test_content_crawler.py::TestColdStartIntegration::test_load_cold_start_posts_blending PASSED [ 28%]
tests/test_content_crawler.py::test_integration_content_crawler_pipeline PASSED [ 28%]
tests/test_database_cleanup.py::TestDatabaseCleanupTasks::test_cleanup_old_rankings_no_data PASSED [ 28%]
tests/test_database_cleanup.py::TestDatabaseCleanupTasks::test_cleanup_old_rankings_with_retention_days PASSED [ 29%]
tests/test_database_cleanup.py::TestDatabaseCleanupTasks::test_cleanup_old_quality_metrics_no_data PASSED [ 29%]
tests/test_database_cleanup.py::TestDatabaseCleanupTasks::test_cleanup_orphaned_data_no_data PASSED [ 29%]
tests/test_database_cleanup.py::TestDatabaseCleanupTasks::test_comprehensive_database_cleanup_dry_run PASSED [ 29%]
tests/test_database_cleanup.py::TestDatabaseCleanupTasks::test_get_database_health_summary PASSED [ 30%]
tests/test_database_cleanup.py::TestDatabaseCleanupTasks::test_cleanup_tasks_error_handling PASSED [ 30%]
tests/test_database_cleanup.py::TestDatabaseCleanupTasks::test_track_cleanup_metrics PASSED [ 30%]
tests/test_db.py::test_record_and_get_interaction PASSED                 [ 30%]
tests/test_db.py::test_get_recommendations PASSED                        [ 30%]
tests/test_db.py::test_cold_start_recommendations PASSED                 [ 31%]
tests/test_db.py::test_recent_posts PASSED                               [ 31%]
tests/test_db_connection.py::test_initialize_connection_pool_success PASSED [ 31%]
tests/test_db_connection.py::test_initialize_connection_pool_failure PASSED [ 31%]
tests/test_db_connection.py::test_get_db_connection_retry_success PASSED [ 32%]
tests/test_db_connection.py::test_get_db_connection_retry_failure PASSED [ 32%]
tests/test_db_connection.py::test_init_db_success PASSED                 [ 32%]
tests/test_db_connection.py::test_init_db_error PASSED                   [ 32%]
tests/test_empty_timeline.py::test_empty_timeline_injection PASSED       [ 33%]
tests/test_empty_timeline.py::test_stub_post_injection PASSED            [ 33%]
tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_missing_user_id FAILED [ 33%]
tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_successful_fresh_timeline FAILED [ 33%]
tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_no_recommendations_returns_404 FAILED [ 34%]
tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_error_handling FAILED [ 34%]
tests/test_health.py::test_health_check_route PASSED                     [ 34%]
tests/test_health.py::test_versioned_health_check_route PASSED           [ 34%]
tests/test_health.py::test_health_check_db_error PASSED                  [ 34%]
tests/test_health.py::test_request_id_header_added PASSED                [ 35%]
tests/test_integration.py::test_authentication_valid_token PASSED        [ 35%]
tests/test_integration.py::test_authentication_invalid_token PASSED      [ 35%]
tests/test_integration.py::test_timeline_retrieval_with_injection PASSED [ 35%]
tests/test_integration.py::test_user_interaction_invalidates_cache PASSED [ 36%]
tests/test_integration.py::test_privacy_settings_impact_on_tracking PASSED [ 36%]
tests/test_integration.py::test_recommendation_caching FAILED            [ 36%]
tests/test_integration.py::test_error_handling_invalid_request PASSED    [ 36%]
tests/test_integration.py::test_complete_user_journey FAILED             [ 37%]
tests/test_interactions.py::test_log_interaction_success PASSED          [ 37%]
tests/test_interactions.py::test_log_interaction_missing_fields PASSED   [ 37%]
tests/test_interactions.py::test_log_interaction_incorrect_types PASSED  [ 37%]
tests/test_interactions.py::test_log_interaction_empty_payload PASSED    [ 38%]
tests/test_interactions.py::test_log_interaction_invalid_action_type PASSED [ 38%]
tests/test_interactions.py::test_get_interactions_by_post PASSED         [ 38%]
tests/test_interactions.py::test_get_user_interactions PASSED            [ 38%]
tests/test_interactions.py::test_get_user_interactions_limited_privacy PASSED [ 38%]
tests/test_interactions.py::test_get_user_interactions_no_privacy PASSED [ 39%]
tests/test_interactions.py::test_get_user_favourites PASSED              [ 39%]
tests/test_interactions_security.py::TestInteractionsSecurityVulnerabilities::test_sql_injection_in_post_ids_batch PASSED [ 39%]
tests/test_interactions_security.py::TestInteractionsSecurityVulnerabilities::test_json_bomb_deep_nesting_attack PASSED [ 39%]
tests/test_interactions_security.py::TestInteractionsSecurityVulnerabilities::test_oversized_json_payload_attack PASSED [ 40%]
tests/test_interactions_security.py::TestInteractionsSecurityVulnerabilities::test_null_byte_injection PASSED [ 40%]
tests/test_interactions_security.py::TestInteractionsSecurityVulnerabilities::test_control_character_injection PASSED [ 40%]
tests/test_interactions_security.py::TestInteractionsSecurityVulnerabilities::test_action_type_injection_attacks[favorite'; DROP TABLE interactions; --] PASSED [ 40%]
tests/test_interactions_security.py::TestInteractionsSecurityVulnerabilities::test_action_type_injection_attacks[favorite' OR '1'='1] PASSED [ 41%]
tests/test_interactions_security.py::TestInteractionsSecurityVulnerabilities::test_action_type_injection_attacks[<script>alert('xss')</script>] PASSED [ 41%]
tests/test_interactions_security.py::TestInteractionsSecurityVulnerabilities::test_cache_invalidation_dos_attack PASSED [ 41%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingAggregator::test_enhanced_trending_score_calculation PASSED [ 41%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingAggregator::test_language_detection_with_confidence PASSED [ 42%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingAggregator::test_batch_language_detection PASSED [ 42%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingAggregator::test_language_statistics_calculation PASSED [ 42%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingAggregator::test_get_language_specific_trending_posts PASSED [ 42%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingAggregator::test_get_language_specific_trending_posts_empty_result PASSED [ 42%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingAggregator::test_enhanced_cold_start_with_language_aware_trending PASSED [ 43%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingAggregator::test_integration_trending_aggregator_full_pipeline PASSED [ 43%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingQualityMetrics::test_trending_score_consistency PASSED [ 43%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingQualityMetrics::test_language_detection_accuracy_requirements PASSED [ 43%]
tests/test_language_aware_trending.py::TestLanguageAwareTrendingQualityMetrics::test_aggregation_performance_characteristics PASSED [ 44%]
tests/test_load_testing_framework.py::TestLoadTestConfiguration::test_basic_configuration_creation PASSED [ 44%]
tests/test_load_testing_framework.py::TestUserProfile::test_user_profile_creation PASSED [ 44%]
tests/test_load_testing_framework.py::TestLoadTestScenarios::test_baseline_performance_scenario PASSED [ 44%]
tests/test_load_testing_framework.py::TestLoadTestScenarios::test_stress_test_scenario PASSED [ 45%]
tests/test_load_testing_framework.py::TestResourceMonitor::test_resource_monitor_initialization PASSED [ 45%]
tests/test_load_testing_framework.py::TestResourceMonitor::test_resource_monitor_lifecycle PASSED [ 45%]
tests/test_load_testing_framework.py::TestLoadTestingFramework::test_framework_initialization PASSED [ 45%]
tests/test_load_testing_framework.py::TestLoadTestingFramework::test_create_mixed_user_set PASSED [ 46%]
tests/test_load_testing_framework.py::TestLoadTestingIntegration::test_baseline_load_test_execution PASSED [ 46%]
tests/test_mastodon_api.py::TestMastodonAPIClient::test_get_fresh_status_success PASSED [ 46%]
tests/test_mastodon_api.py::TestMastodonAPIClient::test_get_fresh_status_not_found PASSED [ 46%]
tests/test_mastodon_api.py::TestMastodonAPIClient::test_get_fresh_status_unauthorized PASSED [ 46%]
tests/test_mastodon_api.py::TestMastodonAPIClient::test_get_fresh_status_timeout PASSED [ 47%]
tests/test_mastodon_api.py::TestMastodonAPIClient::test_instance_url_normalization PASSED [ 47%]
tests/test_mastodon_api.py::TestMastodonAPIClient::test_get_cached_status_hit PASSED [ 47%]
tests/test_mastodon_api.py::TestMastodonAPIClient::test_get_cached_status_miss PASSED [ 47%]
tests/test_mastodon_api.py::TestMastodonAPIClient::test_cache_status_success PASSED [ 48%]
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_no_token_data PASSED [ 48%]
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_empty_recommendations PASSED [ 48%]
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_successful_fresh_fetch PASSED [ 48%]
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_cache_hit_scenario PASSED [ 49%]
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_token_refresh_success PASSED [ 49%]
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_token_refresh_failure PASSED [ 49%]
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_missing_post_omitted PASSED [ 49%]
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_custom_cache_ttl PASSED [ 50%]
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_content_discovery_engine_initialization PASSED [ 50%]
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_instance_timelines PASSED [ 50%]
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_hashtag_streams PASSED [ 50%]
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_follow_relationships PASSED [ 50%]
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_merge_language_breakdowns PASSED [ 51%]
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_get_discovery_summary PASSED [ 51%]
tests/test_multi_source_discovery.py::TestEnhancedPostStorage::test_store_crawled_post_enhanced FAILED [ 51%]
tests/test_multi_source_discovery.py::TestMultiSourceDiscoveryTask::test_celery_task_configuration PASSED [ 51%]
tests/test_multi_source_discovery.py::TestMultiSourceDiscoveryTask::test_discover_content_multi_source_basic_DISABLED SKIPPED [ 52%]
tests/test_multi_source_discovery.py::TestMultiSourceDiscoveryTask::test_discover_content_multi_source_with_failures_DISABLED SKIPPED [ 52%]
tests/test_multi_source_discovery.py::TestDiscoverySourceConstants::test_discovery_source_constants PASSED [ 52%]
tests/test_multi_source_discovery.py::TestDiscoverySourceConstants::test_default_trending_hashtags PASSED [ 52%]
tests/test_multi_source_discovery.py::TestMultiSourceIntegration::test_end_to_end_discovery_workflow PASSED [ 53%]
tests/test_openapi_compliance.py::TestOpenAPICompliance::test_openapi_spec_loads PASSED [ 53%]
tests/test_openapi_compliance.py::TestOpenAPICompliance::test_spec_has_required_sections PASSED [ 53%]
tests/test_openapi_compliance.py::TestOpenAPICompliance::test_health_endpoint_compliance PASSED [ 53%]
tests/test_openapi_compliance.py::TestOpenAPICompliance::test_interactions_post_compliance PASSED [ 53%]
tests/test_openapi_compliance.py::TestOpenAPICompliance::test_privacy_endpoints_compliance PASSED [ 54%]
tests/test_openapi_compliance.py::TestOpenAPICompliance::test_recommendations_endpoint_compliance FAILED [ 54%]
tests/test_openapi_compliance.py::TestOpenAPICompliance::test_error_response_compliance PASSED [ 54%]
tests/test_openapi_compliance.py::TestOpenAPICompliance::test_content_type_compliance PASSED [ 54%]
tests/test_openapi_compliance.py::TestOpenAPICompliance::test_endpoint_tags_coverage PASSED [ 55%]
tests/test_openapi_compliance.py::TestOpenAPISchemaValidation::test_interaction_request_schema PASSED [ 55%]
tests/test_openapi_compliance.py::TestOpenAPISecurityCompliance::test_cors_headers_present PASSED [ 55%]
tests/test_openapi_compliance.py::test_comprehensive_openapi_compliance PASSED [ 55%]
tests/test_performance_api.py::TestGetBenchmarks::test_get_benchmarks_success PASSED [ 56%]
tests/test_performance_api.py::TestGetBenchmarks::test_get_benchmarks_with_filters PASSED [ 56%]
tests/test_performance_api.py::TestGetBenchmarks::test_get_benchmarks_database_error PASSED [ 56%]
tests/test_performance_api.py::TestGetBenchmarkDetails::test_get_benchmark_details_success PASSED [ 56%]
tests/test_performance_api.py::TestGetBenchmarkDetails::test_get_benchmark_details_not_found PASSED [ 57%]
tests/test_performance_api.py::TestCompareBenchmarks::test_compare_benchmarks_success PASSED [ 57%]
tests/test_performance_api.py::TestGetPerformanceTrends::test_get_trends_success PASSED [ 57%]
tests/test_performance_api.py::TestGetRegressionReports::test_get_regressions_success PASSED [ 57%]
tests/test_performance_api.py::TestAnalyzeBenchmarkRegression::test_analyze_regression_success PASSED [ 57%]
tests/test_performance_api.py::TestMonitoringEndpoints::test_get_monitoring_status_success PASSED [ 58%]
tests/test_performance_api.py::TestMonitoringEndpoints::test_create_monitoring_snapshot_success PASSED [ 58%]
tests/test_performance_api.py::TestStatsAndExport::test_get_stats_summary_success PASSED [ 58%]
tests/test_performance_api.py::TestStatsAndExport::test_export_benchmarks_csv PASSED [ 58%]
tests/test_performance_api.py::TestErrorHandling::test_500_error_handler PASSED [ 59%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_single_user_performance PASSED [ 59%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_concurrent_users_performance PASSED [ 59%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_algorithm_latency_thresholds[light] PASSED [ 59%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_algorithm_latency_thresholds[standard] PASSED [ 60%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_algorithm_latency_thresholds[heavy] PASSED [ 60%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_api_throughput_benchmarks[light] PASSED [ 60%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_api_throughput_benchmarks[standard] PASSED [ 60%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_resource_utilization_monitoring PASSED [ 61%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_quality_performance_tradeoff PASSED [ 61%]
tests/test_performance_benchmarks.py::TestPerformanceBenchmarks::test_comprehensive_baseline_establishment PASSED [ 61%]
tests/test_performance_gates.py::TestPerformanceThreshold::test_threshold_creation PASSED [ 61%]
tests/test_performance_gates.py::TestPerformanceGatesEngine::test_compare_values PASSED [ 61%]
tests/test_performance_gates.py::TestPerformanceGatesEngine::test_evaluate_threshold_passed PASSED [ 62%]
tests/test_performance_gates.py::TestPerformanceGatesEngine::test_evaluate_threshold_warning PASSED [ 62%]
tests/test_performance_gates.py::TestPerformanceGatesEngine::test_evaluate_threshold_failed PASSED [ 62%]
tests/test_performance_gates.py::TestPerformanceGatesEngine::test_get_experiment_config PASSED [ 62%]
tests/test_performance_gates.py::TestGateEvaluation::test_gate_evaluation_creation PASSED [ 63%]
tests/test_performance_gates.py::TestPerformanceGatesWorker::test_worker_initialization PASSED [ 63%]
tests/test_performance_gates.py::TestPerformanceGatesWorker::test_worker_start_stop PASSED [ 63%]
tests/test_performance_gates.py::TestPerformanceGatesIntegration::test_evaluate_experiment_performance_gates_function PASSED [ 63%]
tests/test_performance_monitoring.py::TestPerformanceThreshold::test_threshold_creation_and_evaluation PASSED [ 64%]
tests/test_performance_monitoring.py::TestPerformanceThreshold::test_threshold_operators PASSED [ 64%]
tests/test_performance_monitoring.py::TestMetricCollector::test_basic_metric_recording PASSED [ 64%]
tests/test_performance_monitoring.py::TestMetricCollector::test_metric_aggregation PASSED [ 64%]
tests/test_performance_monitoring.py::TestThresholdMonitor::test_threshold_management PASSED [ 65%]
tests/test_performance_monitoring.py::TestThresholdMonitor::test_violation_detection PASSED [ 65%]
tests/test_performance_monitoring.py::TestThresholdMonitor::test_alert_generation PASSED [ 65%]
tests/test_performance_monitoring.py::TestNotificationManager::test_notification_processing PASSED [ 65%]
tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_system_initialization PASSED [ 65%]
tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_request_monitoring PASSED [ 66%]
tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_throughput_recording PASSED [ 66%]
tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_error_rate_calculation PASSED [ 66%]
tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_performance_summary PASSED [ 66%]
tests/test_performance_monitoring.py::TestGlobalMonitorFunctions::test_global_monitor_singleton PASSED [ 67%]
tests/test_performance_monitoring.py::TestGlobalMonitorFunctions::test_monitor_decorator PASSED [ 67%]
tests/test_performance_monitoring.py::TestPerformanceMonitoringIntegration::test_end_to_end_monitoring_workflow PASSED [ 67%]
tests/test_performance_monitoring_complete.py::test_performance_monitoring_complete PASSED [ 67%]
tests/test_performance_monitoring_complete.py::test_database_schema PASSED [ 68%]
tests/test_performance_monitoring_complete.py::test_prometheus_integration PASSED [ 68%]
tests/test_performance_monitoring_complete.py::test_performance_context_manager PASSED [ 68%]
tests/test_performance_monitoring_complete.py::test_real_time_metrics PASSED [ 68%]
tests/test_performance_monitoring_complete.py::test_performance_comparison PASSED [ 69%]
tests/test_performance_monitoring_complete.py::test_middleware_integration PASSED [ 69%]
tests/test_performance_monitoring_complete.py::test_anomaly_detection PASSED [ 69%]
tests/test_performance_monitoring_complete.py::test_api_endpoint_logic PASSED [ 69%]
tests/test_performance_regression_detection.py::TestRegressionThreshold::test_threshold_creation PASSED [ 69%]
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_default_thresholds_creation PASSED [ 70%]
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_classify_regression_type PASSED [ 70%]
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_determine_severity_latency PASSED [ 70%]
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_calculate_metric_change PASSED [ 70%]
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_generate_metric_recommendation PASSED [ 71%]
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_get_benchmark_data PASSED [ 71%]
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_detect_regressions_basic PASSED [ 71%]
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_generate_regression_report PASSED [ 71%]
tests/test_performance_regression_detection.py::TestGlobalFunctions::test_get_regression_detector_singleton PASSED [ 72%]
tests/test_performance_regression_detection.py::TestGlobalFunctions::test_detect_regressions_for_benchmark_convenience PASSED [ 72%]
tests/test_posts.py::test_get_posts FAILED                               [ 72%]
tests/test_posts.py::test_get_posts_with_mastodon_data FAILED            [ 72%]
tests/test_posts.py::test_create_post PASSED                             [ 73%]
tests/test_posts.py::test_create_post_missing_fields PASSED              [ 73%]
tests/test_posts.py::test_get_post_by_id PASSED                          [ 73%]
tests/test_posts.py::test_get_post_not_found PASSED                      [ 73%]
tests/test_posts.py::test_get_posts_by_author PASSED                     [ 73%]
tests/test_posts.py::test_get_trending_posts FAILED                      [ 74%]
tests/test_privacy.py::test_generate_user_alias PASSED                   [ 74%]
tests/test_privacy.py::test_get_user_privacy_level_existing PASSED       [ 74%]
tests/test_privacy.py::test_get_user_privacy_level_default PASSED        [ 74%]
tests/test_privacy.py::test_update_user_privacy_level_success PASSED     [ 75%]
tests/test_privacy.py::test_update_user_privacy_level_invalid PASSED     [ 75%]
tests/test_privacy.py::test_update_user_privacy_level_db_error PASSED    [ 75%]
tests/test_privacy_routes.py::test_get_privacy_settings PASSED           [ 75%]
tests/test_privacy_routes.py::test_get_privacy_settings_missing_user_id PASSED [ 76%]
tests/test_privacy_routes.py::test_update_privacy_settings_success PASSED [ 76%]
tests/test_privacy_routes.py::test_update_privacy_settings_invalid_level PASSED [ 76%]
tests/test_privacy_routes.py::test_update_privacy_settings_missing_fields PASSED [ 76%]
tests/test_proxy.py::TestProxyHelpers::test_get_user_instance_from_header PASSED [ 76%]
tests/test_proxy.py::TestProxyHelpers::test_get_user_instance_default PASSED [ 77%]
tests/test_proxy.py::TestProxyHelpers::test_get_authenticated_user PASSED [ 77%]
tests/test_proxy.py::TestProxyHelpers::test_blend_recommendations PASSED [ 77%]
tests/test_proxy.py::test_proxy_forwarding[custom/endpoint-https://mastodon.social-https://mastodon.social/api/v1/custom/endpoint] PASSED [ 77%]
tests/test_proxy.py::test_proxy_forwarding[statuses/123-https://fosstodon.org-https://fosstodon.org/api/v1/statuses/123] PASSED [ 78%]
tests/test_proxy.py::test_timeline_recommendation_injection PASSED       [ 78%]
tests/test_proxy.py::test_standard_get_passthrough PASSED                [ 78%]
tests/test_proxy.py::test_proxy_error_when_target_instance_fails PASSED  [ 78%]
tests/test_proxy.py::test_proxy_mastodon_5xx_error PASSED                [ 79%]
tests/test_proxy.py::test_auth_header_passthrough PASSED                 [ 79%]
tests/test_proxy_caching.py::TestProxyCacheHelpers::test_generate_proxy_cache_key_public_endpoint PASSED [ 79%]
tests/test_proxy_caching.py::TestProxyCacheHelpers::test_generate_proxy_cache_key_user_specific_endpoint PASSED [ 79%]
tests/test_proxy_caching.py::TestProxyCacheHelpers::test_determine_proxy_cache_ttl_timeline PASSED [ 80%]
tests/test_proxy_caching.py::TestProxyCacheHelpers::test_determine_proxy_cache_ttl_profile PASSED [ 80%]
tests/test_proxy_caching.py::TestProxyCacheHelpers::test_should_cache_proxy_request_valid_get PASSED [ 80%]
tests/test_proxy_caching.py::TestProxyCacheHelpers::test_should_cache_proxy_request_invalid_scenarios PASSED [ 80%]
tests/test_proxy_caching.py::TestProxyEndpointCaching::test_proxy_cache_hit PASSED [ 80%]
tests/test_proxy_caching.py::TestProxyEndpointCaching::test_proxy_caching_disabled PASSED [ 81%]
tests/test_quality_metrics.py::test_quality_metrics PASSED               [ 81%]
tests/test_quality_metrics.py::test_quality_endpoints PASSED             [ 81%]
tests/test_ranking_algorithm.py::test_get_user_interactions PASSED       [ 81%]
tests/test_ranking_algorithm.py::test_get_candidate_posts PASSED         [ 82%]
tests/test_ranking_algorithm.py::test_get_author_preference_score_no_interactions PASSED [ 82%]
tests/test_ranking_algorithm.py::test_get_author_preference_score_no_target_author_interactions PASSED [ 82%]
tests/test_ranking_algorithm.py::test_get_author_preference_score_strong_positive_preference PASSED [ 82%]
tests/test_ranking_algorithm.py::test_get_author_preference_score_mixed_preference PASSED [ 83%]
tests/test_ranking_algorithm.py::test_get_author_preference_score_post_not_in_metadata PASSED [ 83%]
tests/test_ranking_algorithm.py::test_get_author_preference_score_db_error_fallback PASSED [ 83%]
tests/test_ranking_algorithm.py::test_get_content_engagement_score PASSED [ 83%]
tests/test_ranking_algorithm.py::test_get_recency_score PASSED           [ 84%]
tests/test_ranking_algorithm.py::test_calculate_ranking_score PASSED     [ 84%]
tests/test_ranking_algorithm.py::test_generate_rankings_for_user FAILED  [ 84%]
tests/test_ranking_pipeline_integration.py::test_generate_rankings_for_user_order FAILED [ 84%]
tests/test_rate_limiting_integration.py::TestRateLimitingIntegration::test_health_endpoint_rate_limiting PASSED [ 84%]
tests/test_rate_limiting_integration.py::TestRateLimitingIntegration::test_rate_limiting_headers PASSED [ 85%]
tests/test_rate_limiting_integration.py::TestRateLimitingIntegration::test_exemption_for_testing_env PASSED [ 85%]
tests/test_rate_limiting_integration.py::TestRateLimitingIntegration::test_different_endpoints_have_different_limits PASSED [ 85%]
tests/test_rate_limiting_integration.py::TestRateLimitingIntegration::test_user_identification_fallback PASSED [ 85%]
tests/test_rate_limiting_integration.py::TestRateLimitingIntegration::test_authenticated_vs_anonymous_limits PASSED [ 86%]
tests/test_rate_limiting_integration.py::test_rate_limiting_configuration PASSED [ 86%]
tests/test_rate_limiting_integration.py::test_rate_limiting_imports PASSED [ 86%]
tests/test_rbac_functionality.py::test_database_schema FAILED            [ 86%]
tests/test_rbac_functionality.py::test_user_creation_and_role_assignment FAILED [ 87%]
tests/test_rbac_functionality.py::test_permission_checking FAILED        [ 87%]
tests/test_rbac_functionality.py::test_api_endpoints PASSED              [ 87%]
tests/test_recommendation_engine.py::test_load_cold_start_posts PASSED   [ 87%]
tests/test_recommendation_engine.py::test_is_new_user PASSED             [ 88%]
tests/test_recommendation_engine.py::test_get_ranked_recommendations PASSED [ 88%]
tests/test_recommendation_engine.py::test_recommendations_with_mastodon_data PASSED [ 88%]
tests/test_recommendations.py::test_get_recommendations PASSED           [ 88%]
tests/test_recommendations.py::test_get_recommendations_no_rankings PASSED [ 88%]
tests/test_recommendations.py::test_generate_rankings PASSED             [ 89%]
tests/test_recommendations.py::test_generate_rankings_existing PASSED    [ 89%]
tests/test_recommendations.py::test_get_real_posts PASSED                [ 89%]
tests/test_recommendations.py::test_get_recommended_timeline FAILED      [ 89%]
tests/test_recommendations.py::test_recommended_timeline_with_filters FAILED [ 90%]
tests/test_recommendations.py::test_recommended_timeline_parameter_validation FAILED [ 90%]
tests/test_recommendations.py::test_recommended_timeline_auto_generate FAILED [ 90%]
tests/test_responsible_crawling.py::TestInstanceHealthMonitor::test_initial_health_metrics PASSED [ 90%]
tests/test_responsible_crawling.py::TestInstanceHealthMonitor::test_rate_limiting PASSED [ 91%]
tests/test_responsible_crawling.py::TestInstanceHealthMonitor::test_backoff_mechanism PASSED [ 91%]
tests/test_responsible_crawling.py::TestInstanceHealthMonitor::test_health_status_updates PASSED [ 91%]
tests/test_responsible_crawling.py::TestInstanceHealthMonitor::test_request_tracking PASSED [ 91%]
tests/test_responsible_crawling.py::TestResponsibleCrawlingIntegration::test_healthy_instance_selection PASSED [ 92%]
tests/test_responsible_crawling.py::test_crawler_configuration PASSED    [ 92%]
tests/test_scoring_exact.py::test_get_author_preference_score_exact FAILED [ 92%]
tests/test_scoring_exact.py::test_get_content_engagement_score_exact PASSED [ 92%]
tests/test_scoring_exact.py::test_get_recency_score_exact FAILED         [ 92%]
tests/test_scoring_exact.py::test_get_recency_score_floor PASSED         [ 93%]
tests/test_security_interactions.py::TestInteractionsSecurityVulnerabilities::test_json_payload_size_limit PASSED [ 93%]
tests/test_security_interactions.py::TestInteractionsSecurityVulnerabilities::test_deeply_nested_json_attack PASSED [ 93%]
tests/test_security_interactions.py::TestInteractionsSecurityVulnerabilities::test_null_byte_injection_in_strings PASSED [ 93%]
tests/test_security_interactions.py::TestInteractionsSecurityVulnerabilities::test_context_field_schema_pollution PASSED [ 94%]
tests/test_security_interactions.py::TestInteractionsSecurityVulnerabilities::test_batch_request_amplification_attack PASSED [ 94%]
tests/test_security_interactions.py::TestInteractionsSecurityVulnerabilities::test_post_id_injection_attacks PASSED [ 94%]
tests/test_throttling.py::test_throttling PASSED                         [ 94%]
tests/test_timeline.py::test_proxy_home_timeline_synthetic_user PASSED   [ 95%]
tests/test_timeline.py::test_proxy_home_timeline_real_user PASSED        [ 95%]
tests/test_timeline_injection.py::test_uniform_injection PASSED          [ 95%]
tests/test_timeline_injection.py::test_empty_real_posts PASSED           [ 95%]
tests/test_timeline_injection.py::test_tag_match_injection PASSED        [ 96%]
tests/test_timeline_injector.py::test_get_post_timestamp PASSED          [ 96%]
tests/test_timeline_injector.py::test_sort_posts_by_timestamp PASSED     [ 96%]
tests/test_timeline_injector.py::test_extract_tags PASSED                [ 96%]
tests/test_timeline_injector.py::test_tag_as_injected PASSED             [ 96%]
tests/test_timeline_injector.py::test_harmonize_timestamp PASSED         [ 97%]
tests/test_timeline_injector.py::test_uniform_strategy PASSED            [ 97%]
tests/test_timeline_injector.py::test_after_n_strategy PASSED            [ 97%]
tests/test_timeline_injector.py::test_empty_inputs PASSED                [ 97%]
tests/test_token_management.py::TestLiveTokenRefresh::test_live_token_refresh_success PASSED [ 98%]
tests/test_token_management.py::TestLiveTokenRefresh::test_live_token_refresh_missing_refresh_token PASSED [ 98%]
tests/test_token_management.py::TestLiveTokenRefresh::test_live_token_refresh_network_failure PASSED [ 98%]
tests/test_token_management.py::TestTokenExpiryValidation::test_token_expiry_validation_valid_token PASSED [ 98%]
tests/test_token_management.py::TestTokenExpiryValidation::test_token_expiry_validation_expired_token PASSED [ 99%]
tests/test_token_management.py::TestTokenExpiryValidation::test_token_expiry_validation_nearly_expired PASSED [ 99%]
tests/test_token_management.py::TestTokenLifecycleManagement::test_token_creation_and_validation PASSED [ 99%]
tests/test_token_management.py::TestTokenLifecycleManagement::test_token_refresh_timing PASSED [ 99%]
tests/test_token_management.py::TestTokenErrorHandling::test_invalid_refresh_token_handling PASSED [100%]

=================================== FAILURES ===================================
____________________ test_recommendations_timeline_endpoint ____________________

mock_get_db = <MagicMock name='get_db_connection' id='5980422320'>
mock_get_cursor = <MagicMock name='get_cursor' id='5979210672'>
_mock_fetch_rt = <MagicMock name='fetch_real_mastodon_data' id='5978492992'>

    @patch("routes.recommendations.USE_IN_MEMORY_DB", False)
    @patch("routes.recommendations.fetch_real_mastodon_data", return_value=None)
    @patch("routes.recommendations.get_cursor")
    @patch("routes.recommendations.get_db_connection")
    def test_recommendations_timeline_endpoint(mock_get_db, mock_get_cursor, _mock_fetch_rt):
        """Call the /api/v1/recommendations/timeline endpoint and validate the schema of the response."""
    
        # Create a deterministic fake DB row (old format with 10 columns)
        row = (
            "42",  # post_id
            "Hello world",  # content
            "authoruser",  # author_username
            "999",  # author_id
            datetime.datetime.now(),  # created_at
            "mastodon.social",  # source_instance
            5,  # favourites_count
            1,  # reblogs_count
            0,  # replies_count
            0.8,  # trending_score
        )
    
        cursor = _Cursor()
        cursor.fetchall.return_value = [row]
        cursor.execute.return_value = None
    
        # get_cursor should ignore the connection and return our cursor
        mock_get_cursor.side_effect = lambda conn: cursor
    
        # get_db_connection yields a dummy connection usable in a `with` block
        dummy_conn = MagicMock()
        dummy_conn.__enter__.return_value = dummy_conn
        dummy_conn.__exit__.return_value = False
        mock_get_db.return_value = dummy_conn
    
        # Build Flask test client
        app = create_app()
        app.config["TESTING"] = True
        client = app.test_client()
    
        response = client.get("/api/v1/recommendations/timeline?fetch_real_time=false")
        assert response.status_code == 200
    
        data = response.get_json()
>       assert isinstance(data, list) and len(data) > 0
E       assert (True and 0 > 0)
E        +  where True = isinstance([], list)
E        +  and   0 = len([])

tests/test_api_recommendations_timeline.py:61: AssertionError
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:04,501 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:04,503 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:04,503 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:04,503 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:04,503 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:04,503 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:04,503 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:04,503 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:04,503 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:04,503 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:04,503 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:04,503 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:04,518 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:04,518 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:04,522 [INFO] app: Setup GUI enabled - registering blueprint at /setup
2025-06-12 12:00:04,530 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timeline
2025-06-12 12:00:04,530 [INFO] routes.recommendations: TIMELINE-SxPWc6 | Timeline request | User: anonymous | Limit: 20 | Exclude: 0 IDs
2025-06-12 12:00:04,530 [INFO] routes.recommendations: TIMELINE-SxPWc6 | Exclude IDs: []
2025-06-12 12:00:04,530 [INFO] routes.recommendations: REQ-SxPWc6 | Using PostgreSQL database
2025-06-12 12:00:04,531 [INFO] routes.recommendations: TIMELINE-SxPWc6 | Found 0 posts in database
2025-06-12 12:00:04,531 [INFO] routes.recommendations: TIMELINE-SxPWc6 | After deduplication: 0 unique posts
2025-06-12 12:00:04,531 [INFO] routes.recommendations: TIMELINE-SxPWc6 | Returning 0 real posts
2025-06-12 12:00:04,531 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/timeline in 0.002s
2025-06-12 12:00:04,531 [INFO] app: Request GET /api/v1/recommendations/timeline completed with status 200 in 0.001633s
------------------------------ Captured log call -------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timeline
INFO     routes.recommendations:recommendations.py:1635 TIMELINE-SxPWc6 | Timeline request | User: anonymous | Limit: 20 | Exclude: 0 IDs
INFO     routes.recommendations:recommendations.py:1636 TIMELINE-SxPWc6 | Exclude IDs: []
INFO     routes.recommendations:recommendations.py:1706 REQ-SxPWc6 | Using PostgreSQL database
INFO     routes.recommendations:recommendations.py:1745 TIMELINE-SxPWc6 | Found 0 posts in database
INFO     routes.recommendations:recommendations.py:1766 TIMELINE-SxPWc6 | After deduplication: 0 unique posts
INFO     routes.recommendations:recommendations.py:1768 TIMELINE-SxPWc6 | Returning 0 real posts
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/timeline in 0.002s
INFO     app:app.py:189 Request GET /api/v1/recommendations/timeline completed with status 200 in 0.001633s
_________ TestAsyncRecommendations.test_recommendations_sync_fallback __________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13cabfbf0>
client = <FlaskClient <Flask 'app'>>

    def test_recommendations_sync_fallback(self, client):
        """Test that recommendations work when async is disabled."""
        # Test sync behavior is preserved
        response = client.get('/api/v1/recommendations?user_id=test_user&async=false')
    
        # Should get some kind of response (200 or 404 if no data)
        assert response.status_code in [200, 404]
    
        if response.status_code == 200:
            data = response.get_json()
            assert 'user_id' in data
            assert data['user_id'] == 'test_user'
            assert 'recommendations' in data
>           assert 'source' in data
E           AssertionError: assert 'source' in {'debug_info': {'error_occurred': True}, 'message': 'Unable to generate recommendations at this time', 'recommendations': [], 'user_id': 'test_user'}

tests/test_async_recommendations.py:45: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:04,592 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:04,594 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:04,594 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:04,594 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:04,594 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:04,594 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:04,594 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:04,594 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:04,594 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:04,594 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:04,594 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:04,594 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:04,610 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:04,610 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:04,614 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:04,623 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations
2025-06-12 12:00:04,623 [ERROR] routes.recommendations: Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
2025-06-12 12:00:04,623 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations in 0.000s
2025-06-12 12:00:04,623 [INFO] app: Request GET /api/v1/recommendations completed with status 200 in 0.000440s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations
ERROR    routes.recommendations:recommendations.py:1176 Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations in 0.000s
INFO     app:app.py:189 Request GET /api/v1/recommendations completed with status 200 in 0.000440s
_____ TestAsyncRecommendations.test_recommendations_parameters_validation ______

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13cabfe00>
client = <FlaskClient <Flask 'app'>>

    def test_recommendations_parameters_validation(self, client):
        """Test parameter validation for the recommendations endpoint."""
        # Test missing user_id
        response = client.get('/api/v1/recommendations')
        assert response.status_code == 400
        data = response.get_json()
        assert 'error' in data
        assert 'user_id' in data['error']
    
        # Test invalid limit
        response = client.get('/api/v1/recommendations?user_id=test&limit=150')
>       assert response.status_code == 400
E       assert 200 == 400
E        +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_async_recommendations.py:58: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:04,630 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:04,633 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:04,633 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:04,633 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:04,633 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:04,633 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:04,633 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:04,633 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:04,633 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:04,633 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:04,633 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:04,633 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:04,648 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:04,648 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:04,651 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:04,661 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations
2025-06-12 12:00:04,661 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations in 0.000s
2025-06-12 12:00:04,661 [WARNING] app: Request GET /api/v1/recommendations completed with status 400 in 0.000324s
2025-06-12 12:00:04,662 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations
2025-06-12 12:00:04,662 [ERROR] routes.recommendations: Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
2025-06-12 12:00:04,662 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations in 0.000s
2025-06-12 12:00:04,662 [INFO] app: Request GET /api/v1/recommendations completed with status 200 in 0.000310s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations in 0.000s
WARNING  app:app.py:189 Request GET /api/v1/recommendations completed with status 400 in 0.000324s
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations
ERROR    routes.recommendations:recommendations.py:1176 Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations in 0.000s
INFO     app:app.py:189 Request GET /api/v1/recommendations completed with status 200 in 0.000310s
_______________ TestAsyncRecommendations.test_async_task_queuing _______________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13cabffb0>
client = <FlaskClient <Flask 'app'>>

    @pytest.mark.skipif(not ASYNC_TASKS_AVAILABLE, reason="Async tasks not available")
    def test_async_task_queuing(self, client):
        """Test async task queuing when async=true."""
>       with patch('routes.recommendations.generate_rankings_async') as mock_task:

tests/test_async_recommendations.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x1698cde80>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'routes.recommendations' from '/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/routes/recommendations.py'> does not have the attribute 'generate_rankings_async'

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1428: AttributeError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:04,669 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:04,670 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:04,670 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:04,671 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:04,671 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:04,671 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:04,671 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:04,671 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:04,671 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:04,671 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:04,671 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:04,671 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:04,687 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:04,687 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:04,690 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
______________ TestAsyncRecommendations.test_task_status_endpoint ______________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13caf8050>
client = <FlaskClient <Flask 'app'>>

    @pytest.mark.skipif(not ASYNC_TASKS_AVAILABLE, reason="Async tasks not available")
    def test_task_status_endpoint(self, client):
        """Test the task status polling endpoint."""
        with patch('utils.celery_app.celery') as mock_celery:
            # Mock successful task
            mock_result = Mock()
            mock_result.state = 'SUCCESS'
            mock_result.result = {
                'user_id': 'test_user',
                'rankings_count': 10,
                'processing_time': 2.5,
                'cache_key': 'async_rankings:test_user'
            }
            mock_result.info = mock_result.result
            mock_celery.AsyncResult.return_value = mock_result
    
            response = client.get('/api/v1/recommendations/status/test-task-123')
    
            assert response.status_code == 200
            data = response.get_json()
    
            assert data['task_id'] == 'test-task-123'
>           assert data['state'] == 'SUCCESS'
E           KeyError: 'state'

tests/test_async_recommendations.py:112: KeyError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:04,763 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:04,766 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:04,766 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:04,766 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:04,766 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:04,766 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:04,766 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:04,766 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:04,766 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:04,767 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:04,767 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:04,767 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:04,782 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:04,782 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:04,786 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:04,795 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/status/test-task-123
2025-06-12 12:00:04,796 [INFO] routes.recommendations: Checking status for task: test-task-123
2025-06-12 12:00:04,796 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/status/test-task-123 in 0.000s
2025-06-12 12:00:04,796 [INFO] app: Request GET /api/v1/recommendations/status/test-task-123 completed with status 200 in 0.000404s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/status/test-task-123
INFO     routes.recommendations:recommendations.py:1403 Checking status for task: test-task-123
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/status/test-task-123 in 0.000s
INFO     app:app.py:189 Request GET /api/v1/recommendations/status/test-task-123 completed with status 200 in 0.000404s
______________ TestAsyncRecommendations.test_task_status_pending _______________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13caf8200>
client = <FlaskClient <Flask 'app'>>

    @pytest.mark.skipif(not ASYNC_TASKS_AVAILABLE, reason="Async tasks not available")
    def test_task_status_pending(self, client):
        """Test task status when task is pending."""
        with patch('utils.celery_app.celery') as mock_celery:
            mock_result = Mock()
            mock_result.state = 'PENDING'
            mock_celery.AsyncResult.return_value = mock_result
    
            response = client.get('/api/v1/recommendations/status/test-task-123')
    
            assert response.status_code == 200
            data = response.get_json()
    
>           assert data['state'] == 'PENDING'
E           KeyError: 'state'

tests/test_async_recommendations.py:131: KeyError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:04,803 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:04,805 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:04,805 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:04,805 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:04,805 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:04,805 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:04,805 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:04,805 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:04,805 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:04,805 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:04,805 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:04,805 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:04,820 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:04,820 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:04,824 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:04,834 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/status/test-task-123
2025-06-12 12:00:04,834 [INFO] routes.recommendations: Checking status for task: test-task-123
2025-06-12 12:00:04,834 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/status/test-task-123 in 0.000s
2025-06-12 12:00:04,834 [INFO] app: Request GET /api/v1/recommendations/status/test-task-123 completed with status 200 in 0.000382s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/status/test-task-123
INFO     routes.recommendations:recommendations.py:1403 Checking status for task: test-task-123
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/status/test-task-123 in 0.000s
INFO     app:app.py:189 Request GET /api/v1/recommendations/status/test-task-123 completed with status 200 in 0.000382s
______________ TestAsyncRecommendations.test_task_status_failure _______________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13caf83b0>
client = <FlaskClient <Flask 'app'>>

    @pytest.mark.skipif(not ASYNC_TASKS_AVAILABLE, reason="Async tasks not available")
    def test_task_status_failure(self, client):
        """Test task status when task failed."""
        with patch('utils.celery_app.celery') as mock_celery:
            mock_result = Mock()
            mock_result.state = 'FAILURE'
            mock_result.info = {'error': 'Test error', 'user_id': 'test_user'}
            mock_celery.AsyncResult.return_value = mock_result
    
            response = client.get('/api/v1/recommendations/status/test-task-123')
    
>           assert response.status_code == 500  # Failed tasks correctly return 500
E           assert 200 == 500
E            +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_async_recommendations.py:146: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:04,841 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:04,843 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:04,843 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:04,843 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:04,843 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:04,843 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:04,843 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:04,843 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:04,843 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:04,843 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:04,843 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:04,843 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:04,858 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:04,858 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:04,862 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:04,870 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/status/test-task-123
2025-06-12 12:00:04,870 [INFO] routes.recommendations: Checking status for task: test-task-123
2025-06-12 12:00:04,871 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/status/test-task-123 in 0.000s
2025-06-12 12:00:04,871 [INFO] app: Request GET /api/v1/recommendations/status/test-task-123 completed with status 200 in 0.000321s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/status/test-task-123
INFO     routes.recommendations:recommendations.py:1403 Checking status for task: test-task-123
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/status/test-task-123 in 0.000s
INFO     app:app.py:189 Request GET /api/v1/recommendations/status/test-task-123 completed with status 200 in 0.000321s
_______________ TestAsyncRecommendations.test_task_cancellation ________________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13caf8560>
client = <FlaskClient <Flask 'app'>>

    @pytest.mark.skipif(not ASYNC_TASKS_AVAILABLE, reason="Async tasks not available")
    def test_task_cancellation(self, client):
        """Test task cancellation endpoint."""
        with patch('utils.celery_app.celery') as mock_celery:
            # Mock task that can be cancelled
            mock_result = Mock()
            mock_result.state = 'PENDING'
            mock_celery.AsyncResult.return_value = mock_result
    
            # Mock control.revoke
            mock_celery.control.revoke = Mock()
    
            response = client.delete('/api/v1/recommendations/status/test-task-123')
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_async_recommendations.py:168: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:04,878 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:04,879 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:04,879 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:04,879 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:04,880 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:04,880 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:04,880 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:04,880 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:04,880 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:04,880 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:04,880 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:04,880 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:04,896 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:04,896 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:04,899 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:04,908 [INFO] utils.logging_decorator: Request received: DELETE /api/v1/recommendations/status/test-task-123
2025-06-12 12:00:04,908 [WARNING] routes.proxy: No instance found in request, using default: https://mastodon.social
2025-06-12 12:00:04,908 [INFO] routes.proxy: HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


2025-06-12 12:00:04,908 [INFO] proxy: REQ-2023844 | DELETE /recommendations/status/test-task-123 | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
2025-06-12 12:00:05,347 [INFO] proxy: UP-2023844 | Upstream response | Status: 404 | Time: 0.439s | Size: 1503 bytes
2025-06-12 12:00:05,347 [INFO] proxy: RESP-2023844 | Request completed | Status: 404 | Total time: 0.440s | Enriched: not_applicable
2025-06-12 12:00:05,348 [INFO] utils.logging_decorator: Request completed: DELETE /api/v1/recommendations/status/test-task-123 in 0.440s
2025-06-12 12:00:05,348 [WARNING] app: Request DELETE /api/v1/recommendations/status/test-task-123 completed with status 404 in 0.440578s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: DELETE /api/v1/recommendations/status/test-task-123
WARNING  routes.proxy:proxy.py:300 No instance found in request, using default: https://mastodon.social
INFO     routes.proxy:proxy.py:352 HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


INFO     proxy:proxy.py:984 REQ-2023844 | DELETE /recommendations/status/test-task-123 | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
INFO     proxy:proxy.py:1121 UP-2023844 | Upstream response | Status: 404 | Time: 0.439s | Size: 1503 bytes
INFO     proxy:proxy.py:1283 RESP-2023844 | Request completed | Status: 404 | Total time: 0.440s | Enriched: not_applicable
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: DELETE /api/v1/recommendations/status/test-task-123 in 0.440s
WARNING  app:app.py:189 Request DELETE /api/v1/recommendations/status/test-task-123 completed with status 404 in 0.440578s
_____________ TestAsyncRecommendations.test_task_cancel_completed ______________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13caf8710>
client = <FlaskClient <Flask 'app'>>

    @pytest.mark.skipif(not ASYNC_TASKS_AVAILABLE, reason="Async tasks not available")
    def test_task_cancel_completed(self, client):
        """Test attempting to cancel an already completed task."""
        with patch('utils.celery_app.celery') as mock_celery:
            mock_result = Mock()
            mock_result.state = 'SUCCESS'
            mock_result.result = {'user_id': 'test_user', 'rankings_count': 10}
            mock_celery.AsyncResult.return_value = mock_result
    
            response = client.delete('/api/v1/recommendations/status/test-task-123')
    
>           assert response.status_code == 410  # Gone
E           assert 404 == 410
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_async_recommendations.py:189: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:05,361 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:05,364 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:05,364 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:05,364 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:05,364 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:05,365 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:05,368 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:05,368 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:05,368 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:05,369 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:05,369 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:05,369 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:05,407 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:05,407 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:05,415 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:05,428 [INFO] utils.logging_decorator: Request received: DELETE /api/v1/recommendations/status/test-task-123
2025-06-12 12:00:05,428 [WARNING] routes.proxy: No instance found in request, using default: https://mastodon.social
2025-06-12 12:00:05,428 [INFO] routes.proxy: HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


2025-06-12 12:00:05,429 [INFO] proxy: REQ-4188149 | DELETE /recommendations/status/test-task-123 | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
2025-06-12 12:00:05,794 [INFO] proxy: UP-4188149 | Upstream response | Status: 404 | Time: 0.365s | Size: 1503 bytes
2025-06-12 12:00:05,800 [INFO] proxy: RESP-4188149 | Request completed | Status: 404 | Total time: 0.372s | Enriched: not_applicable
2025-06-12 12:00:05,801 [INFO] utils.logging_decorator: Request completed: DELETE /api/v1/recommendations/status/test-task-123 in 0.373s
2025-06-12 12:00:05,801 [WARNING] app: Request DELETE /api/v1/recommendations/status/test-task-123 completed with status 404 in 0.373349s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: DELETE /api/v1/recommendations/status/test-task-123
WARNING  routes.proxy:proxy.py:300 No instance found in request, using default: https://mastodon.social
INFO     routes.proxy:proxy.py:352 HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


INFO     proxy:proxy.py:984 REQ-4188149 | DELETE /recommendations/status/test-task-123 | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
INFO     proxy:proxy.py:1121 UP-4188149 | Upstream response | Status: 404 | Time: 0.365s | Size: 1503 bytes
INFO     proxy:proxy.py:1283 RESP-4188149 | Request completed | Status: 404 | Total time: 0.372s | Enriched: not_applicable
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: DELETE /api/v1/recommendations/status/test-task-123 in 0.373s
WARNING  app:app.py:189 Request DELETE /api/v1/recommendations/status/test-task-123 completed with status 404 in 0.373349s
___________ TestAsyncRecommendations.test_async_unavailable_fallback ___________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13caf88c0>
client = <FlaskClient <Flask 'app'>>

    def test_async_unavailable_fallback(self, client):
        """Test behavior when async functionality is not available."""
        if ASYNC_TASKS_AVAILABLE:
            # Mock async being unavailable
            with patch('routes.recommendations.ASYNC_TASKS_AVAILABLE', False):
                response = client.get('/api/v1/recommendations?user_id=test_user&async=true')
    
                # Should fall back to sync processing
                assert response.status_code in [200, 404]
                data = response.get_json()
                assert 'recommendations' in data or 'user_id' in data
    
                # Status endpoint should return 503
                response = client.get('/api/v1/recommendations/status/any-task')
>               assert response.status_code == 503
E               assert 200 == 503
E                +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_async_recommendations.py:209: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:05,821 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:05,835 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:05,835 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:05,835 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:05,835 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:05,835 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:05,835 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:05,835 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:05,835 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:05,835 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:05,836 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:05,836 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:05,857 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:05,857 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:05,863 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:05,876 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations
2025-06-12 12:00:05,876 [ERROR] routes.recommendations: Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
2025-06-12 12:00:05,876 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations in 0.000s
2025-06-12 12:00:05,877 [INFO] app: Request GET /api/v1/recommendations completed with status 200 in 0.000613s
2025-06-12 12:00:05,878 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/status/any-task
2025-06-12 12:00:05,878 [INFO] routes.recommendations: Checking status for task: any-task
2025-06-12 12:00:05,878 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/status/any-task in 0.000s
2025-06-12 12:00:05,878 [INFO] app: Request GET /api/v1/recommendations/status/any-task completed with status 200 in 0.000418s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations
ERROR    routes.recommendations:recommendations.py:1176 Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations in 0.000s
INFO     app:app.py:189 Request GET /api/v1/recommendations completed with status 200 in 0.000613s
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/status/any-task
INFO     routes.recommendations:recommendations.py:1403 Checking status for task: any-task
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/status/any-task in 0.000s
INFO     app:app.py:189 Request GET /api/v1/recommendations/status/any-task completed with status 200 in 0.000418s
_____________ TestAsyncRecommendations.test_hybrid_cache_behavior ______________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13caf8a70>
client = <FlaskClient <Flask 'app'>>

    def test_hybrid_cache_behavior(self, client):
        """Test the hybrid cache behavior (stale cache + background refresh)."""
        with patch('utils.cache.get_cached_recommendations') as mock_get_cache:
            with patch('utils.cache.cache_get') as mock_cache_get:
>               with patch('routes.recommendations.generate_rankings_async') as mock_task:

tests/test_async_recommendations.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x169b95340>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'routes.recommendations' from '/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/routes/recommendations.py'> does not have the attribute 'generate_rankings_async'

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1428: AttributeError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:05,887 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:05,889 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:05,889 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:05,889 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:05,889 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:05,889 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:05,889 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:05,890 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:05,890 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:05,890 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:05,890 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:05,890 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:05,907 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:05,907 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:05,911 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
____________ TestAsyncRecommendations.test_processing_time_tracking ____________

self = <tests.test_async_recommendations.TestAsyncRecommendations object at 0x13caf8c20>
client = <FlaskClient <Flask 'app'>>

    def test_processing_time_tracking(self, client):
        """Test that processing times are tracked in responses."""
        response = client.get('/api/v1/recommendations?user_id=test_user')
    
        if response.status_code == 200:
            data = response.get_json()
>           assert 'processing_time_ms' in data
E           AssertionError: assert 'processing_time_ms' in {'debug_info': {'error_occurred': True}, 'message': 'Unable to generate recommendations at this time', 'recommendations': [], 'user_id': 'test_user'}

tests/test_async_recommendations.py:249: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:05,983 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:05,985 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:05,985 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:05,985 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:05,985 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:05,985 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:05,985 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:05,985 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:05,985 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:05,985 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:05,985 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:05,985 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:06,000 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:06,000 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:06,004 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:06,013 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations
2025-06-12 12:00:06,013 [ERROR] routes.recommendations: Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
2025-06-12 12:00:06,013 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations in 0.000s
2025-06-12 12:00:06,013 [INFO] app: Request GET /api/v1/recommendations completed with status 200 in 0.000432s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations
ERROR    routes.recommendations:recommendations.py:1176 Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations in 0.000s
INFO     app:app.py:189 Request GET /api/v1/recommendations completed with status 200 in 0.000432s
_______________ TestAsyncIntegration.test_end_to_end_async_flow ________________

self = <tests.test_async_recommendations.TestAsyncIntegration object at 0x13caf8fe0>
client = <FlaskClient <Flask 'app'>>

    def test_end_to_end_async_flow(self, client):
        """Test complete async flow from request to completion."""
        if not ASYNC_TASKS_AVAILABLE:
            pytest.skip("Async tasks not available")
    
>       with patch('routes.recommendations.generate_rankings_async') as mock_task:

tests/test_async_recommendations.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1455: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x169e474d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'routes.recommendations' from '/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/routes/recommendations.py'> does not have the attribute 'generate_rankings_async'

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1428: AttributeError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:06,021 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:06,023 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:06,023 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:06,023 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:06,023 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:06,023 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:06,023 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:06,024 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:06,024 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:06,024 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:06,024 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:06,024 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:06,040 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:06,040 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:06,043 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
________________ TestFreshTimelineEndpoint.test_missing_user_id ________________

self = <tests.test_fresh_timeline.TestFreshTimelineEndpoint object at 0x13efe4c80>

    def test_missing_user_id(self):
        """Test that missing user_id returns 400."""
        response = self.client.get('/api/v1/recommendations/timelines/fresh')
    
>       assert response.status_code == 400
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_fresh_timeline.py:43: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:06,454 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:06,455 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:06,455 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:06,455 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:06,455 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:06,456 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:06,456 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:06,456 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:06,456 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:06,456 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:06,456 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:06,456 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:06,471 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:06,472 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:06,475 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:06,484 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timelines/fresh
2025-06-12 12:00:06,484 [WARNING] routes.proxy: No instance found in request, using default: https://mastodon.social
2025-06-12 12:00:06,484 [INFO] routes.proxy: HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


2025-06-12 12:00:06,484 [INFO] proxy: REQ-2851033 | GET /recommendations/timelines/fresh | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
2025-06-12 12:00:07,055 [INFO] proxy: UP-2851033 | Upstream response | Status: 404 | Time: 0.571s | Size: 1503 bytes
2025-06-12 12:00:07,056 [INFO] proxy: RESP-2851033 | Request completed | Status: 404 | Total time: 0.572s | Enriched: not_applicable
2025-06-12 12:00:07,056 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/timelines/fresh in 0.572s
2025-06-12 12:00:07,056 [WARNING] app: Request GET /api/v1/recommendations/timelines/fresh completed with status 404 in 0.572403s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timelines/fresh
WARNING  routes.proxy:proxy.py:300 No instance found in request, using default: https://mastodon.social
INFO     routes.proxy:proxy.py:352 HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


INFO     proxy:proxy.py:984 REQ-2851033 | GET /recommendations/timelines/fresh | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
INFO     proxy:proxy.py:1121 UP-2851033 | Upstream response | Status: 404 | Time: 0.571s | Size: 1503 bytes
INFO     proxy:proxy.py:1283 RESP-2851033 | Request completed | Status: 404 | Total time: 0.572s | Enriched: not_applicable
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/timelines/fresh in 0.572s
WARNING  app:app.py:189 Request GET /api/v1/recommendations/timelines/fresh completed with status 404 in 0.572403s
___________ TestFreshTimelineEndpoint.test_successful_fresh_timeline ___________

self = <tests.test_fresh_timeline.TestFreshTimelineEndpoint object at 0x13efe4e60>

    def test_successful_fresh_timeline(self):
        """Test successful fresh timeline retrieval."""
        with self.app.app_context():
            # First, create some recommendations in the database
            from db.connection import get_db_connection, get_cursor
            from utils.privacy import generate_user_alias
    
            user_alias = generate_user_alias(self.test_user_id)
    
            with get_db_connection() as conn:
                with get_cursor(conn) as cur:
                    # Insert test recommendations
                    cur.execute(
                        "INSERT INTO recommendations (user_id, post_id, score, reason) VALUES (?, ?, ?, ?)",
                        (user_alias, "112345678901234567", 0.95, "High engagement content")
                    )
                    cur.execute(
                        "INSERT INTO recommendations (user_id, post_id, score, reason) VALUES (?, ?, ?, ?)",
                        (user_alias, "112345678901234568", 0.88, "Similar topic interest")
                    )
                    conn.commit()
    
            response = self.client.get(f'/api/v1/recommendations/timelines/fresh?user_id={self.test_user_id}')
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_fresh_timeline.py:71: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:07,064 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:07,066 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:07,066 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:07,066 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:07,066 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:07,066 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:07,067 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:07,067 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:07,067 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:07,067 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:07,067 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:07,067 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:07,097 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:07,098 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:07,104 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:07,116 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timelines/fresh
2025-06-12 12:00:07,116 [WARNING] routes.proxy: No instance found in request, using default: https://mastodon.social
2025-06-12 12:00:07,116 [INFO] routes.proxy: HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


2025-06-12 12:00:07,116 [INFO] proxy: REQ-2832530 | GET /recommendations/timelines/fresh | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
2025-06-12 12:00:07,413 [INFO] proxy: UP-2832530 | Upstream response | Status: 404 | Time: 0.296s | Size: 1503 bytes
2025-06-12 12:00:07,414 [INFO] proxy: RESP-2832530 | Request completed | Status: 404 | Total time: 0.298s | Enriched: not_applicable
2025-06-12 12:00:07,414 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/timelines/fresh in 0.298s
2025-06-12 12:00:07,415 [WARNING] app: Request GET /api/v1/recommendations/timelines/fresh completed with status 404 in 0.298834s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timelines/fresh
WARNING  routes.proxy:proxy.py:300 No instance found in request, using default: https://mastodon.social
INFO     routes.proxy:proxy.py:352 HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


INFO     proxy:proxy.py:984 REQ-2832530 | GET /recommendations/timelines/fresh | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
INFO     proxy:proxy.py:1121 UP-2832530 | Upstream response | Status: 404 | Time: 0.296s | Size: 1503 bytes
INFO     proxy:proxy.py:1283 RESP-2832530 | Request completed | Status: 404 | Total time: 0.298s | Enriched: not_applicable
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/timelines/fresh in 0.298s
WARNING  app:app.py:189 Request GET /api/v1/recommendations/timelines/fresh completed with status 404 in 0.298834s
________ TestFreshTimelineEndpoint.test_no_recommendations_returns_404 _________

self = <tests.test_fresh_timeline.TestFreshTimelineEndpoint object at 0x13efe5010>
mock_get_fresh_status = <MagicMock name='get_fresh_status' id='6070008720'>
mock_get_token = <MagicMock name='get_user_token_data' id='6070003008'>

    @patch('utils.mastodon_api.get_user_token_data')
    @patch('utils.mastodon_api.mastodon_client.get_fresh_status')
    def test_no_recommendations_returns_404(self, mock_get_fresh_status, mock_get_token):
        """Test fresh timeline with no recommendations returns 404."""
        with self.app.app_context():
            # Clean up any existing recommendations first
            from db.connection import get_db_connection, get_cursor
            from utils.privacy import generate_user_alias
    
            user_alias = generate_user_alias(self.test_user_id)
    
            with get_db_connection() as conn:
                with get_cursor(conn) as cur:
                    # Clear any existing recommendations
                    cur.execute("DELETE FROM recommendations WHERE user_id = ?", (user_alias,))
                    conn.commit()
    
            # Mock token data (won't be called in this case)
            mock_get_token.return_value = self.mock_token_data
    
            # Mock the fetch function to return our test data (won't be called)
            mock_get_fresh_status.return_value = None
    
            response = self.client.get(
                '/api/v1/recommendations/timelines/fresh',
                query_string={'user_id': self.test_user_id}
            )
    
            # With no recommendations in DB, this should return 404
            assert response.status_code == 404
            data = response.get_json()
>           assert data['message'] == 'No recommendations found. Try generating rankings first.'
E           TypeError: 'NoneType' object is not subscriptable

tests/test_fresh_timeline.py:117: TypeError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:07,428 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:07,434 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:07,434 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:07,434 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:07,434 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:07,434 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:07,435 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:07,435 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:07,435 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:07,435 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:07,435 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:07,435 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:07,468 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:07,469 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:07,474 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:07,487 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timelines/fresh
2025-06-12 12:00:07,487 [WARNING] routes.proxy: No instance found in request, using default: https://mastodon.social
2025-06-12 12:00:07,487 [INFO] routes.proxy: HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


2025-06-12 12:00:07,487 [INFO] proxy: REQ-7864881 | GET /recommendations/timelines/fresh | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
2025-06-12 12:00:07,942 [INFO] proxy: UP-7864881 | Upstream response | Status: 404 | Time: 0.454s | Size: 1503 bytes
2025-06-12 12:00:07,942 [INFO] proxy: RESP-7864881 | Request completed | Status: 404 | Total time: 0.455s | Enriched: not_applicable
2025-06-12 12:00:07,942 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/timelines/fresh in 0.455s
2025-06-12 12:00:07,943 [WARNING] app: Request GET /api/v1/recommendations/timelines/fresh completed with status 404 in 0.455745s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timelines/fresh
WARNING  routes.proxy:proxy.py:300 No instance found in request, using default: https://mastodon.social
INFO     routes.proxy:proxy.py:352 HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


INFO     proxy:proxy.py:984 REQ-7864881 | GET /recommendations/timelines/fresh | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
INFO     proxy:proxy.py:1121 UP-7864881 | Upstream response | Status: 404 | Time: 0.454s | Size: 1503 bytes
INFO     proxy:proxy.py:1283 RESP-7864881 | Request completed | Status: 404 | Total time: 0.455s | Enriched: not_applicable
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/timelines/fresh in 0.455s
WARNING  app:app.py:189 Request GET /api/v1/recommendations/timelines/fresh completed with status 404 in 0.455745s
________________ TestFreshTimelineEndpoint.test_error_handling _________________

self = <tests.test_fresh_timeline.TestFreshTimelineEndpoint object at 0x13efe51f0>

    def test_error_handling(self):
        """Test error handling for API failures."""
        with self.app.app_context():
            # Clean up any existing recommendations first
            from db.connection import get_db_connection, get_cursor
            from utils.privacy import generate_user_alias
    
            user_alias = generate_user_alias(self.test_user_id)
    
            with get_db_connection() as conn:
                with get_cursor(conn) as cur:
                    # Clear any existing recommendations
                    cur.execute("DELETE FROM recommendations WHERE user_id = ?", (user_alias,))
    
                    # Insert test recommendations
                    cur.execute(
                        "INSERT INTO recommendations (user_id, post_id, score, reason) VALUES (?, ?, ?, ?)",
                        (user_alias, "112345678901234567", 0.95, "High engagement content")
                    )
                    conn.commit()
    
            # Test with invalid user_id to trigger error path
            response = self.client.get('/api/v1/recommendations/timelines/fresh?user_id=')
    
            # Should handle error gracefully
>           assert response.status_code == 400
E           assert 404 == 400
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code

tests/test_fresh_timeline.py:150: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:07,948 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:07,950 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:07,950 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:07,950 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:07,950 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:07,950 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:07,950 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:07,950 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:07,950 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:07,950 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:07,951 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:07,951 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:07,968 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:07,968 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:07,972 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:07,981 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timelines/fresh
2025-06-12 12:00:07,981 [WARNING] routes.proxy: No instance found in request, using default: https://mastodon.social
2025-06-12 12:00:07,981 [INFO] routes.proxy: HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


2025-06-12 12:00:07,981 [INFO] proxy: REQ-5010048 | GET /recommendations/timelines/fresh | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
2025-06-12 12:00:08,432 [INFO] proxy: UP-5010048 | Upstream response | Status: 404 | Time: 0.450s | Size: 1503 bytes
2025-06-12 12:00:08,433 [INFO] proxy: RESP-5010048 | Request completed | Status: 404 | Total time: 0.451s | Enriched: not_applicable
2025-06-12 12:00:08,433 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/timelines/fresh in 0.452s
2025-06-12 12:00:08,433 [WARNING] app: Request GET /api/v1/recommendations/timelines/fresh completed with status 404 in 0.452362s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timelines/fresh
WARNING  routes.proxy:proxy.py:300 No instance found in request, using default: https://mastodon.social
INFO     routes.proxy:proxy.py:352 HEADERS: User-Agent: Werkzeug/3.0.6
Host: localhost


INFO     proxy:proxy.py:984 REQ-5010048 | GET /recommendations/timelines/fresh | Target: https://mastodon.social | User: anonymous | Client: 127.0.0.1 | UA: Werkzeug/3.0.6
INFO     proxy:proxy.py:1121 UP-5010048 | Upstream response | Status: 404 | Time: 0.450s | Size: 1503 bytes
INFO     proxy:proxy.py:1283 RESP-5010048 | Request completed | Status: 404 | Total time: 0.451s | Enriched: not_applicable
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/timelines/fresh in 0.452s
WARNING  app:app.py:189 Request GET /api/v1/recommendations/timelines/fresh completed with status 404 in 0.452362s
_________________________ test_recommendation_caching __________________________

mock_rankings = <MagicMock name='generate_rankings_for_user' id='6066885152'>
client = <FlaskClient <Flask 'app'>>
setup_test_db = (<MagicMock name='get_db_connection()' id='5978208112'>, <MagicMock name='get_db_connection().cursor().__enter__()' id='6065212160'>)
test_user = {'auth_token': 'test_token_user1', 'instance': 'https://mastodon.test', 'user_id': 'test_user_integration'}
redis_mock = (<MagicMock name='get_redis_client()' id='5978233584'>, {})

    @patch('core.ranking_algorithm.generate_rankings_for_user')
    def test_recommendation_caching(
        mock_rankings, client, setup_test_db, test_user, redis_mock
    ):
        """Test recommendation caching behavior."""
        mock_client, mock_cache = redis_mock
    
        # Mock ranking generation
        mock_rankings.return_value = [
            {"post_id": "rec_1", "score": 0.9},
            {"post_id": "rec_2", "score": 0.8}
        ]
    
        # First request should call ranking function
        response = client.get(
            f'{API_PREFIX}/recommendations',
            headers={'Authorization': f'Bearer {test_user["auth_token"]}'}
        )
    
        # Should respond appropriately
>       assert response.status_code in [200, 401]
E       assert 400 in [200, 401]
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code

tests/test_integration.py:275: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:08,767 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:08,768 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:08,769 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:08,769 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:08,769 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:08,769 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:08,769 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:08,769 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:08,769 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:08,769 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:08,769 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:08,769 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:08,785 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:08,785 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:08,788 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:08,799 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations
2025-06-12 12:00:08,799 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations in 0.000s
2025-06-12 12:00:08,799 [WARNING] app: Request GET /api/v1/recommendations completed with status 400 in 0.000497s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations in 0.000s
WARNING  app:app.py:189 Request GET /api/v1/recommendations completed with status 400 in 0.000497s
__________________________ test_complete_user_journey __________________________

client = <FlaskClient <Flask 'app'>>
setup_test_db = (<MagicMock name='get_db_connection()' id='5979620368'>, <MagicMock name='get_db_connection().cursor().__enter__()' id='5979634672'>)
test_user = {'auth_token': 'test_token_user1', 'instance': 'https://mastodon.test', 'user_id': 'test_user_integration'}
test_posts = [{'account': {'display_name': 'Test User 1', 'id': 'account_1', 'username': 'test_user_1'}, 'content': 'Test post cont...t_user_2'}, 'content': 'Test post content 5', 'created_at': '2025-06-12T12:00:08.876628', 'favourites_count': 50, ...}]
mock_mastodon_api = (<MagicMock name='request' id='5977979312'>, <MagicMock name='request()' id='5312872128'>)
redis_mock = (<MagicMock name='get_redis_client()' id='5978990464'>, {})

    def test_complete_user_journey(
        client, setup_test_db, test_user, test_posts, mock_mastodon_api, redis_mock
    ):
        """Test complete user journey from auth to interactions."""
        mock_request, mock_response = mock_mastodon_api
        mock_response.json.return_value = test_posts
        mock_client, mock_cache = redis_mock
    
        # Mock the auth token system for authentication
        with patch('routes.oauth.auth_tokens.get_token') as mock_get_token:
            mock_get_token.return_value = {
                "user_id": test_user["user_id"],
                "instance": test_user["instance"],
                "created_at": "2024-01-01T00:00:00Z"
            }
    
            # 1. Authentication
            auth_response = client.get(
                f'{API_PREFIX}/user/me',
                headers={'Authorization': f'Bearer {test_user["auth_token"]}'}
            )
    
            assert auth_response.status_code == 200
    
            # 2. Get recommendations
            rec_response = client.get(
                f'{API_PREFIX}/recommendations',
                headers={'Authorization': f'Bearer {test_user["auth_token"]}'}
            )
    
>           assert rec_response.status_code in [200, 401]
E           assert 400 in [200, 401]
E            +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code

tests/test_integration.py:322: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:08,839 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:08,848 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:08,848 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:08,848 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:08,848 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:08,848 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:08,848 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:08,848 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:08,848 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:08,848 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:08,848 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:08,849 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:08,864 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:08,864 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:08,868 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:08,878 [INFO] utils.logging_decorator: Request received: GET /api/v1/user/me
2025-06-12 12:00:08,879 [INFO] utils.logging_decorator: Request completed: GET /api/v1/user/me in 0.000s
2025-06-12 12:00:08,879 [INFO] app: Request GET /api/v1/user/me completed with status 200 in 0.000285s
2025-06-12 12:00:08,879 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations
2025-06-12 12:00:08,879 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations in 0.000s
2025-06-12 12:00:08,880 [WARNING] app: Request GET /api/v1/recommendations completed with status 400 in 0.000214s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/user/me
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/user/me in 0.000s
INFO     app:app.py:189 Request GET /api/v1/user/me completed with status 200 in 0.000285s
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations in 0.000s
WARNING  app:app.py:189 Request GET /api/v1/recommendations completed with status 400 in 0.000214s
___________ TestEnhancedPostStorage.test_store_crawled_post_enhanced ___________

self = <tests.test_multi_source_discovery.TestEnhancedPostStorage object at 0x13f8c04d0>
mock_db_conn = <MagicMock name='get_db_connection' id='5979277408'>

    @patch('tasks.content_crawler.get_db_connection')
    def test_store_crawled_post_enhanced(self, mock_db_conn):
        """Test enhanced post storage with discovery source metadata."""
        # Mock database connection
        mock_cursor = MagicMock()
        mock_cursor.fetchone.return_value = None  # No duplicate
        mock_cursor.execute.return_value = None
    
        # Create test post
        test_post = MastodonPost(
            id="enhanced_test_post",
            content="Test post for enhanced storage",
            created_at=datetime.now(timezone.utc),
            author_id="test_author",
            author_username="testuser",
            favourites_count=5,
            reblogs_count=2,
            replies_count=1,
            tags=["test", "enhanced"]
        )
    
        # Test enhanced storage
        result = store_crawled_post_enhanced(
            cursor=mock_cursor,
            post=test_post,
            instance="test.instance",
            session_id="test_session",
            detected_language="en",
            engagement_velocity=2.5,
            trending_score=15.7,
            discovery_source=DiscoverySource.HASHTAG_STREAM,
            source_detail="#technology"
        )
    
        # Verify storage was successful
        assert result == True
    
        # Verify enhanced INSERT was called
        assert mock_cursor.execute.call_count == 2  # 1 check + 1 insert
        insert_call = mock_cursor.execute.call_args_list[1]
        insert_query = insert_call[0][0]
        insert_params = insert_call[0][1]
    
        # Verify enhanced fields are included
        assert 'discovery_metadata' in insert_query
    
        # Verify enhanced metadata in parameters
        metadata_json = insert_params[-1]  # Last parameter should be metadata
>       metadata = json.loads(metadata_json)

tests/test_multi_source_discovery.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x102695340>, s = '#technology'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/json/decoder.py:355: JSONDecodeError
________ TestOpenAPICompliance.test_recommendations_endpoint_compliance ________

self = <tests.test_openapi_compliance.TestOpenAPICompliance object at 0x13fdc7530>
client = <FlaskClient <Flask 'app'>>
openapi_validator = <tests.test_openapi_compliance.OpenAPISpecValidator object at 0x169d44470>

    def test_recommendations_endpoint_compliance(self, client, openapi_validator):
        """Test recommendations endpoint compliance"""
        # Add Authorization header for recommendations
        headers = {'Authorization': 'Bearer test_token_123'}
        response = client.get('/api/v1/recommendations', headers=headers)
    
        # Should return proper format regardless of auth
>       assert response.status_code in [200, 401]
E       assert 400 in [200, 401]
E        +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code

tests/test_openapi_compliance.py:164: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:17,930 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:17,931 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:17,931 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:17,931 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:17,931 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:17,932 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:17,932 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:17,932 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:17,932 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:17,932 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:17,932 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:17,932 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:17,947 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:17,947 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:17,951 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:18,083 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations
2025-06-12 12:00:18,083 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations in 0.000s
2025-06-12 12:00:18,084 [WARNING] app: Request GET /api/v1/recommendations completed with status 400 in 0.000416s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations in 0.000s
WARNING  app:app.py:189 Request GET /api/v1/recommendations completed with status 400 in 0.000416s
________________________________ test_get_posts ________________________________

mock_get_db = <MagicMock name='get_db_connection' id='6084356352'>
client = <FlaskClient <Flask 'app'>>
mock_db_conn = (<MagicMock name='get_db_connection()' id='5978681424'>, <MagicMock name='get_db_connection().cursor()' id='6067067392'>)

    @patch('routes.posts.get_db_connection')
    def test_get_posts(mock_get_db, client, mock_db_conn):
        """Test retrieving posts list."""
        # Setup mock
        mock_conn, mock_cursor = mock_db_conn
        mock_get_db.return_value = mock_conn
    
        # Mock data for a regular post without mastodon data
        mock_cursor.fetchall.return_value = [
            ("post123", "author456", "Author Name", "Post content", "text",
             None, {"favorites": 10, "reblogs": 5}, None),
        ]
    
        # Make request
        response = client.get(f'{API_PREFIX}/posts')
    
        # Verify response
        assert response.status_code == 200
        data = json.loads(response.data)
        assert len(data) == 1
        assert data[0]["id"] == "post123"
>       assert data[0]["favourites_count"] == 10
E       assert 0 == 10

tests/test_posts.py:43: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:25,578 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:25,580 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:25,580 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:25,580 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:25,580 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:25,581 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:25,581 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:25,581 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:25,581 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:25,581 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:25,581 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:25,581 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:25,604 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:25,604 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:25,609 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:25,620 [INFO] utils.logging_decorator: Request received: GET /api/v1/posts
2025-06-12 12:00:25,621 [INFO] utils.logging_decorator: Request completed: GET /api/v1/posts in 0.001s
2025-06-12 12:00:25,621 [INFO] app: Request GET /api/v1/posts completed with status 200 in 0.001078s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/posts
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/posts in 0.001s
INFO     app:app.py:189 Request GET /api/v1/posts completed with status 200 in 0.001078s
______________________ test_get_posts_with_mastodon_data _______________________

mock_get_db = <MagicMock name='get_db_connection' id='5977973936'>
client = <FlaskClient <Flask 'app'>>
mock_db_conn = (<MagicMock name='get_db_connection()' id='6070812064'>, <MagicMock name='get_db_connection().cursor()' id='6070798480'>)

    @patch('routes.posts.get_db_connection')
    def test_get_posts_with_mastodon_data(mock_get_db, client, mock_db_conn):
        """Test retrieving posts list with mastodon post data."""
        # Setup mock
        mock_conn, mock_cursor = mock_db_conn
        mock_get_db.return_value = mock_conn
    
        # Mock mastodon post data
        mastodon_post = {
            "id": "post123",
            "account": {"username": "mastodon_user"},
            "content": "<p>Mastodon post content</p>",
            "favourites_count": 42
        }
    
        # Mock data with mastodon data
        mock_cursor.fetchall.return_value = [
            ("post123", "author456", "Author Name", "Post content", "text",
             None, {"favorites": 10, "reblogs": 5}, json.dumps(mastodon_post)),
        ]
    
        # Make request
        response = client.get(f'{API_PREFIX}/posts')
    
        # Verify response
        assert response.status_code == 200
        data = json.loads(response.data)
        assert len(data) == 1
        assert data[0]["id"] == "post123"
>       assert data[0]["favourites_count"] == 42  # Should use mastodon data
E       assert 0 == 42

tests/test_posts.py:86: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:25,627 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:25,629 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:25,630 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:25,630 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:25,630 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:25,630 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:25,630 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:25,630 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:25,630 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:25,630 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:25,630 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:25,630 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:25,646 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:25,646 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:25,650 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:25,660 [INFO] utils.logging_decorator: Request received: GET /api/v1/posts
2025-06-12 12:00:25,661 [INFO] utils.logging_decorator: Request completed: GET /api/v1/posts in 0.001s
2025-06-12 12:00:25,661 [INFO] app: Request GET /api/v1/posts completed with status 200 in 0.001034s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/posts
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/posts in 0.001s
INFO     app:app.py:189 Request GET /api/v1/posts completed with status 200 in 0.001034s
___________________________ test_get_trending_posts ____________________________

mock_get_db = <MagicMock name='get_db_connection' id='6065216960'>
client = <FlaskClient <Flask 'app'>>
mock_db_conn = (<MagicMock name='get_db_connection()' id='6066254768'>, <MagicMock name='get_db_connection().cursor()' id='6066254384'>)

    @patch('routes.posts.get_db_connection')
    def test_get_trending_posts(mock_get_db, client, mock_db_conn):
        """Test retrieving trending posts."""
        # Setup mock
        mock_conn, mock_cursor = mock_db_conn
        mock_get_db.return_value = mock_conn
    
        # Mock trending posts data with total_interactions
        mock_cursor.fetchall.return_value = [
            ("post123", "author456", "Author Name", "Popular post", "text",
             None, {"favorites": 100, "reblogs": 50}, 150, None),
            ("post789", "author456", "Author Name", "Less popular post", "text",
             None, {"favorites": 20, "reblogs": 10}, 30, None),
        ]
    
        # Make request - use correct API prefix
        response = client.get(f'{API_PREFIX}/posts/trending')
    
        # Verify response
        assert response.status_code == 200
        data = json.loads(response.data)
        assert len(data) == 2
        assert data[0]["id"] == "post123"
>       assert data[0]["favourites_count"] == 100
E       assert 0 == 100

tests/test_posts.py:247: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:25,839 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:25,842 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:25,842 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:25,842 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:25,842 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:25,842 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:25,842 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:25,842 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:25,842 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:25,842 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:25,843 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:25,843 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:25,857 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:25,857 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:25,861 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:25,872 [INFO] utils.logging_decorator: Request received: GET /api/v1/posts/trending
2025-06-12 12:00:25,872 [INFO] utils.logging_decorator: Request completed: GET /api/v1/posts/trending in 0.001s
2025-06-12 12:00:25,872 [INFO] app: Request GET /api/v1/posts/trending completed with status 200 in 0.000871s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/posts/trending
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/posts/trending in 0.001s
INFO     app:app.py:189 Request GET /api/v1/posts/trending completed with status 200 in 0.000871s
_______________________ test_generate_rankings_for_user ________________________

mock_get_interactions = <MagicMock name='get_user_interactions' id='6090901984'>
mock_get_candidates = <MagicMock name='get_candidate_posts' id='6090909472'>
mock_generate_alias = <MagicMock name='generate_user_alias' id='6090913264'>
mock_get_conn = <MagicMock name='get_db_connection' id='6090917072'>
mock_db_conn = (<MagicMock name='get_db_connection()' id='6090870752'>, <MagicMock name='get_db_connection().cursor()' id='6090874400'>)

    @patch('core.ranking_algorithm.get_db_connection')
    @patch('core.ranking_algorithm.generate_user_alias')
    @patch('core.ranking_algorithm.get_candidate_posts')
    @patch('core.ranking_algorithm.get_user_interactions')
    def test_generate_rankings_for_user(mock_get_interactions, mock_get_candidates, mock_generate_alias, mock_get_conn, mock_db_conn):
        """Test the full ranking generation process."""
        mock_conn, mock_cursor = mock_db_conn
        mock_get_conn.return_value = mock_conn
    
        # Mock the user alias
        user_alias = 'hashed_user_id'
        mock_generate_alias.return_value = user_alias
    
        # Mock interactions data
        from datetime import datetime
        now = datetime.now()
    
        # Mock user interactions (for post-to-author mapping)
        mock_get_interactions.return_value = [
            {'post_id': 'seen_post1', 'action_type': 'favorite', 'created_at': now}
        ]
    
        # Mock candidate posts (already processed format from get_candidate_posts)
        mock_get_candidates.return_value = [
            {
                'post_id': 'post123',
                'author_id': 'author1',
                'author_name': 'Author One',
                'content': 'Content 1',
                'created_at': now,
                'interaction_counts': {'favorites': 5}
            },
            {
                'post_id': 'post456',
                'author_id': 'author2',
                'author_name': 'Author Two',
                'content': 'Content 2',
                'created_at': now,
                'interaction_counts': {'favorites': 10}
            }
        ]
    
        # Mock the post-to-author mapping query (for author preference calculation)
        mock_cursor.fetchall.return_value = [('seen_post1', 'author1')]
    
        # Mock the scoring functions
        with patch('core.ranking_algorithm.get_author_preference_score', return_value=0.5):
            with patch('core.ranking_algorithm.get_content_engagement_score', return_value=0.6):
                with patch('core.ranking_algorithm.get_recency_score', return_value=0.7):
                    # Call the function
                    result = generate_rankings_for_user('user123')
    
                    # Verify ranked posts are returned
>                   assert len(result) > 0
E                   assert 0 > 0
E                    +  where 0 = len([])

tests/test_ranking_algorithm.py:372: AssertionError
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:26,432 [INFO] core.ranking_algorithm: Using default algorithm configuration for user hashed_user_id
2025-06-12 12:00:26,432 [INFO] core.ranking_algorithm: Retrieved 1 interactions for user hashed_user_id
2025-06-12 12:00:26,433 [ERROR] core.ranking_algorithm: Error generating rankings: cannot import name 'MIN_RANKING_SCORE' from '<unknown module name>' (unknown location)
2025-06-12 12:00:26,433 [ERROR] core.ranking_algorithm: Traceback: Traceback (most recent call last):
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/core/ranking_algorithm.py", line 575, in generate_rankings_for_user
    from config import MIN_RANKING_SCORE
ImportError: cannot import name 'MIN_RANKING_SCORE' from '<unknown module name>' (unknown location)

------------------------------ Captured log call -------------------------------
INFO     core.ranking_algorithm:ranking_algorithm.py:538 Using default algorithm configuration for user hashed_user_id
INFO     core.ranking_algorithm:ranking_algorithm.py:543 Retrieved 1 interactions for user hashed_user_id
ERROR    core.ranking_algorithm:ranking_algorithm.py:640 Error generating rankings: cannot import name 'MIN_RANKING_SCORE' from '<unknown module name>' (unknown location)
ERROR    core.ranking_algorithm:ranking_algorithm.py:643 Traceback: Traceback (most recent call last):
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/core/ranking_algorithm.py", line 575, in generate_rankings_for_user
    from config import MIN_RANKING_SCORE
ImportError: cannot import name 'MIN_RANKING_SCORE' from '<unknown module name>' (unknown location)
____________________ test_generate_rankings_for_user_order _____________________

setup_test_data = '5cf03b2344bf9c8bfde8f0804cadaf72a5537bf2ade82d2ee20596948da6923b'

    def test_generate_rankings_for_user_order(setup_test_data):
        """Run the full ranking pipeline and ensure AuthorX posts outrank AuthorY."""
        ranked_posts = generate_rankings_for_user("userA")
    
        # Sanity check  we inserted two *candidate* posts
>       assert len(ranked_posts) == 2
E       assert 0 == 2
E        +  where 0 = len([])

tests/test_ranking_pipeline_integration.py:84: AssertionError
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:26,440 [INFO] core.ranking_algorithm: Using default algorithm configuration for user 5cf03b2344bf9c8bfde8f0804cadaf72a5537bf2ade82d2ee20596948da6923b
2025-06-12 12:00:26,440 [INFO] core.ranking_algorithm: Retrieved 3 interactions for user 5cf03b2344bf9c8bfde8f0804cadaf72a5537bf2ade82d2ee20596948da6923b
2025-06-12 12:00:26,440 [INFO] core.ranking_algorithm: Database contains 20 real posts and 0 synthetic posts
2025-06-12 12:00:26,440 [INFO] core.ranking_algorithm: Found 17 candidate posts
2025-06-12 12:00:26,440 [ERROR] core.ranking_algorithm: Error generating rankings: 'post_author_id'
2025-06-12 12:00:26,440 [ERROR] core.ranking_algorithm: Traceback: Traceback (most recent call last):
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/core/ranking_algorithm.py", line 572, in generate_rankings_for_user
    score, reason = calculate_ranking_score(post, user_interactions, algorithm_config)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/core/ranking_algorithm.py", line 426, in calculate_ranking_score
    reason_detail = generate_specific_recommendation_reason_from_ranking(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/core/ranking_algorithm.py", line 470, in generate_specific_recommendation_reason_from_ranking
    author_interactions = [i for i in user_interactions if i['post_author_id'] == post['author_id']]
                                                           ~^^^^^^^^^^^^^^^^^^
KeyError: 'post_author_id'

------------------------------ Captured log call -------------------------------
INFO     core.ranking_algorithm:ranking_algorithm.py:538 Using default algorithm configuration for user 5cf03b2344bf9c8bfde8f0804cadaf72a5537bf2ade82d2ee20596948da6923b
INFO     core.ranking_algorithm:ranking_algorithm.py:543 Retrieved 3 interactions for user 5cf03b2344bf9c8bfde8f0804cadaf72a5537bf2ade82d2ee20596948da6923b
INFO     core.ranking_algorithm:ranking_algorithm.py:170 Database contains 20 real posts and 0 synthetic posts
INFO     core.ranking_algorithm:ranking_algorithm.py:219 Found 17 candidate posts
ERROR    core.ranking_algorithm:ranking_algorithm.py:640 Error generating rankings: 'post_author_id'
ERROR    core.ranking_algorithm:ranking_algorithm.py:643 Traceback: Traceback (most recent call last):
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/core/ranking_algorithm.py", line 572, in generate_rankings_for_user
    score, reason = calculate_ranking_score(post, user_interactions, algorithm_config)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/core/ranking_algorithm.py", line 426, in calculate_ranking_score
    reason_detail = generate_specific_recommendation_reason_from_ranking(
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/core/ranking_algorithm.py", line 470, in generate_specific_recommendation_reason_from_ranking
    author_interactions = [i for i in user_interactions if i['post_author_id'] == post['author_id']]
                                                           ~^^^^^^^^^^^^^^^^^^
KeyError: 'post_author_id'
_____________________________ test_database_schema _____________________________

self = <sqlalchemy.engine.base.Connection object at 0x16b0a33e0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x16a975d60>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16b0c1370>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x16b0a3fb0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x16a975d60>
cursor = <sqlite3.Cursor object at 0x13ff6e2c0>
statement = 'SELECT count(*) AS count_1 \nFROM (SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles...AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at \nFROM roles) AS anon_1'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16b0c1370>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: roles

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/default.py:942: OperationalError

The above exception was the direct cause of the following exception:

    def test_database_schema():
        """Test that all RBAC tables exist and have data."""
        print(" Testing database schema...")
    
        with db_session() as session:
            # Check tables exist and have data
>           role_count = session.query(Role).count()

tests/test_rbac_functionality.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/query.py:3147: in count
    self._legacy_from_self(col).enable_eagerloads(False).scalar()
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2836: in scalar
    ret = self.one()
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2809: in one
    return self._iter().one()  # type: ignore
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2858: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x16a975d60>
cursor = <sqlite3.Cursor object at 0x13ff6e2c0>
statement = 'SELECT count(*) AS count_1 \nFROM (SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles...AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at \nFROM roles) AS anon_1'
parameters = ()
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16b0c1370>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: roles
E       [SQL: SELECT count(*) AS count_1 
E       FROM (SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS roles_description, roles.is_system_role AS roles_is_system_role, roles.is_active AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at 
E       FROM roles) AS anon_1]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/default.py:942: OperationalError
----------------------------- Captured stdout call -----------------------------
 Testing database schema...
2025-06-12 12:00:26,754 [ERROR] db.session: Database error: (sqlite3.OperationalError) no such table: roles
[SQL: SELECT count(*) AS count_1 
FROM (SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS roles_description, roles.is_system_role AS roles_is_system_role, roles.is_active AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at 
FROM roles) AS anon_1]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
------------------------------ Captured log call -------------------------------
ERROR    db.session:session.py:205 Database error: (sqlite3.OperationalError) no such table: roles
[SQL: SELECT count(*) AS count_1 
FROM (SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS roles_description, roles.is_system_role AS roles_is_system_role, roles.is_active AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at 
FROM roles) AS anon_1]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
____________________ test_user_creation_and_role_assignment ____________________

self = <sqlalchemy.engine.base.Connection object at 0x16afb4440>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x16a975d60>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16afb4740>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x16afb72f0>
parameters = [('admin', 1, 0)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x16a975d60>
cursor = <sqlite3.Cursor object at 0x13cb33740>
statement = 'SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS...ed_at AS roles_created_at, roles.updated_at AS roles_updated_at \nFROM roles \nWHERE roles.name = ?\n LIMIT ? OFFSET ?'
parameters = ('admin', 1, 0)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16afb4740>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: roles

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/default.py:942: OperationalError

The above exception was the direct cause of the following exception:

    def test_user_creation_and_role_assignment():
        """Test creating a user and assigning roles."""
        print("\n Testing user creation and role assignment...")
    
        with db_session() as session:
            # Check if test user exists
            test_user = session.query(DashboardUser).filter_by(
                email="test_admin@example.com"
            ).first()
    
            if not test_user:
                # Create test user
                test_user = DashboardUser(
                    email="test_admin@example.com",
                    name="Test Admin User",
                    oauth_provider="test",
                    oauth_id="test_123"
                )
                session.add(test_user)
                session.commit()
                print(" Created test user")
            else:
                print(" Test user already exists")
    
            # Assign admin role
>           admin_role = session.query(Role).filter_by(name="admin").first()

tests/test_rbac_functionality.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2759: in first
    return self.limit(1)._iter().first()  # type: ignore
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2858: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x16a975d60>
cursor = <sqlite3.Cursor object at 0x13cb33740>
statement = 'SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS...ed_at AS roles_created_at, roles.updated_at AS roles_updated_at \nFROM roles \nWHERE roles.name = ?\n LIMIT ? OFFSET ?'
parameters = ('admin', 1, 0)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16afb4740>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: roles
E       [SQL: SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS roles_description, roles.is_system_role AS roles_is_system_role, roles.is_active AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at 
E       FROM roles 
E       WHERE roles.name = ?
E        LIMIT ? OFFSET ?]
E       [parameters: ('admin', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/default.py:942: OperationalError
----------------------------- Captured stdout call -----------------------------

 Testing user creation and role assignment...
 Test user already exists
2025-06-12 12:00:27,142 [ERROR] db.session: Database error: (sqlite3.OperationalError) no such table: roles
[SQL: SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS roles_description, roles.is_system_role AS roles_is_system_role, roles.is_active AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at 
FROM roles 
WHERE roles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('admin', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
------------------------------ Captured log call -------------------------------
ERROR    db.session:session.py:205 Database error: (sqlite3.OperationalError) no such table: roles
[SQL: SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS roles_description, roles.is_system_role AS roles_is_system_role, roles.is_active AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at 
FROM roles 
WHERE roles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('admin', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
___________________________ test_permission_checking ___________________________

self = <sqlalchemy.engine.base.Connection object at 0x16afb69c0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x16a975d60>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16afb7c20>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x16afb67e0>
parameters = [(1,)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x16a975d60>
cursor = <sqlite3.Cursor object at 0x169d14740>
statement = 'SELECT user_roles.id AS user_roles_id, user_roles.user_id AS user_roles_user_id, user_roles.role_id AS user_roles_rol...S user_roles_expires_at, user_roles.is_active AS user_roles_is_active \nFROM user_roles \nWHERE ? = user_roles.user_id'
parameters = (1,)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16afb7c20>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: user_roles

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/default.py:942: OperationalError

The above exception was the direct cause of the following exception:

    def test_permission_checking():
        """Test permission checking functionality."""
        print("\n Testing permission checking...")
    
        with db_session() as session:
            test_user = session.query(DashboardUser).filter_by(
                email="test_admin@example.com"
            ).first()
    
            if test_user:
                # Test various permissions
                test_permissions = [
                    "users:read",
                    "analytics:read",
                    "experiments:write",
                    "system:admin",
                    "nonexistent:permission"
                ]
    
                for perm in test_permissions:
>                   has_perm = test_user.has_permission(perm)

tests/test_rbac_functionality.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
db/models.py:346: in has_permission
    for user_role in self.user_roles:
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/attributes.py:566: in __get__
    return self.impl.get(state, dict_)  # type: ignore[no-any-return]
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/attributes.py:1086: in get
    value = self._fire_loader_callables(state, key, passive)
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/attributes.py:1121: in _fire_loader_callables
    return self.callable_(state, passive)
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:978: in _load_for_state
    return self._emit_lazyload(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/strategies.py:1141: in _emit_lazyload
    result = session.execute(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1638: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1983: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2352: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1964: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x16a975d60>
cursor = <sqlite3.Cursor object at 0x169d14740>
statement = 'SELECT user_roles.id AS user_roles_id, user_roles.user_id AS user_roles_user_id, user_roles.role_id AS user_roles_rol...S user_roles_expires_at, user_roles.is_active AS user_roles_is_active \nFROM user_roles \nWHERE ? = user_roles.user_id'
parameters = (1,)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16afb7c20>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: user_roles
E       [SQL: SELECT user_roles.id AS user_roles_id, user_roles.user_id AS user_roles_user_id, user_roles.role_id AS user_roles_role_id, user_roles.assigned_by AS user_roles_assigned_by, user_roles.assigned_at AS user_roles_assigned_at, user_roles.expires_at AS user_roles_expires_at, user_roles.is_active AS user_roles_is_active 
E       FROM user_roles 
E       WHERE ? = user_roles.user_id]
E       [parameters: (1,)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/sqlalchemy/engine/default.py:942: OperationalError
----------------------------- Captured stdout call -----------------------------

 Testing permission checking...
2025-06-12 12:00:27,520 [ERROR] db.session: Database error: (sqlite3.OperationalError) no such table: user_roles
[SQL: SELECT user_roles.id AS user_roles_id, user_roles.user_id AS user_roles_user_id, user_roles.role_id AS user_roles_role_id, user_roles.assigned_by AS user_roles_assigned_by, user_roles.assigned_at AS user_roles_assigned_at, user_roles.expires_at AS user_roles_expires_at, user_roles.is_active AS user_roles_is_active 
FROM user_roles 
WHERE ? = user_roles.user_id]
[parameters: (1,)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
------------------------------ Captured log call -------------------------------
ERROR    db.session:session.py:205 Database error: (sqlite3.OperationalError) no such table: user_roles
[SQL: SELECT user_roles.id AS user_roles_id, user_roles.user_id AS user_roles_user_id, user_roles.role_id AS user_roles_role_id, user_roles.assigned_by AS user_roles_assigned_by, user_roles.assigned_at AS user_roles_assigned_at, user_roles.expires_at AS user_roles_expires_at, user_roles.is_active AS user_roles_is_active 
FROM user_roles 
WHERE ? = user_roles.user_id]
[parameters: (1,)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
________________________ test_get_recommended_timeline _________________________

mock_get_db = <MagicMock name='get_db_connection' id='5979764256'>
client = <FlaskClient <Flask 'app'>>
mock_db_conn = (<MagicMock name='get_db_connection()' id='6066578992'>, <MagicMock name='get_db_connection().cursor()' id='6082264384'>)

    @patch('routes.recommendations.get_db_connection')
    def test_get_recommended_timeline(mock_get_db, client, mock_db_conn):
        """Test getting recommended timeline posts."""
        # Setup mocks
        mock_conn, mock_cursor = mock_db_conn
        mock_get_db.return_value = mock_conn
    
        # Mock database results for SQLite mode
        mock_cursor.fetchone.return_value = (5,)  # 5 recommendations
    
        # Sample post data
        post1 = {
            "post_id": "post123",
            "score": 0.95,
            "reason": "Based on your interests",
            "content": "This is recommended post 1",
            "author_id": "user1",
            "created_at": "2025-04-19T10:00:00Z",
            "metadata": json.dumps({
                "author_name": "Author One",
                "tags": ["tech", "ai"]
            })
        }
    
        post2 = {
            "post_id": "post456",
            "score": 0.82,
            "reason": "Popular in your network",
            "content": "This is recommended post 2",
            "author_id": "user2",
            "created_at": "2025-04-19T09:30:00Z",
            "metadata": json.dumps({
                "author_name": "Author Two",
                "tags": ["news", "politics"]
            })
        }
    
        # Mock the fetchall result - properly formatted as rows
        mock_cursor.fetchall.return_value = [
            (post1["post_id"], post1["score"], post1["reason"], post1["content"],
             post1["author_id"], post1["created_at"], post1["metadata"]),
    
            (post2["post_id"], post2["score"], post2["reason"], post2["content"],
             post2["author_id"], post2["created_at"], post2["metadata"])
        ]
    
        # Mock USE_IN_MEMORY_DB to be True for SQLite testing
        with patch('routes.recommendations.USE_IN_MEMORY_DB', True):
            # Test the endpoint
            response = client.get(f'{API_PREFIX}/recommendations/timelines/recommended?user_id=user123&limit=10')
    
            # Verify response
>           assert response.status_code == 200
E           assert 500 == 200
E            +  where 500 = <WrapperTestResponse streamed [500 INTERNAL SERVER ERROR]>.status_code

tests/test_recommendations.py:349: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:28,174 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:28,176 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:28,176 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:28,176 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:28,176 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:28,176 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:28,176 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:28,176 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:28,176 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:28,176 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:28,176 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:28,177 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:28,192 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:28,192 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:28,196 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:28,206 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timelines/recommended
2025-06-12 12:00:28,206 [INFO] routes.recommendations: ELK-COMPAT | Before defaults - username: Author One, display_name: Author One
2025-06-12 12:00:28,206 [INFO] routes.recommendations: ELK-COMPAT | Setting acct to anonymous (was: None)
2025-06-12 12:00:28,206 [INFO] routes.recommendations: ELK-COMPAT | After defaults - username: Author One, display_name: Author One
2025-06-12 12:00:28,207 [INFO] routes.recommendations: ELK-COMPAT | Before defaults - username: Author Two, display_name: Author Two
2025-06-12 12:00:28,207 [INFO] routes.recommendations: ELK-COMPAT | Setting acct to anonymous (was: None)
2025-06-12 12:00:28,207 [INFO] routes.recommendations: ELK-COMPAT | After defaults - username: Author Two, display_name: Author Two
2025-06-12 12:00:28,207 [ERROR] utils.logging_decorator: Error in get_recommended_timeline: name 'request_id' is not defined
2025-06-12 12:00:28,210 [ERROR] utils.logging_decorator: Traceback (most recent call last):
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/logging_decorator.py", line 50, in decorated_function
    result = f(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/routes/recommendations.py", line 947, in get_recommended_timeline
    logger.info(f"TIMELINE-{request_id} | First post after build_simple_posts_from_rows:")
                            ^^^^^^^^^^
NameError: name 'request_id' is not defined. Did you mean: 'requests'?

2025-06-12 12:00:28,210 [INFO] utils.logging_decorator: Request failed: GET /api/v1/recommendations/timelines/recommended in 0.004s
2025-06-12 12:00:28,210 [WARNING] app: Request GET /api/v1/recommendations/timelines/recommended completed with status 500 in 0.004232s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timelines/recommended
INFO     routes.recommendations:recommendations.py:482 ELK-COMPAT | Before defaults - username: Author One, display_name: Author One
INFO     routes.recommendations:recommendations.py:490 ELK-COMPAT | Setting acct to anonymous (was: None)
INFO     routes.recommendations:recommendations.py:496 ELK-COMPAT | After defaults - username: Author One, display_name: Author One
INFO     routes.recommendations:recommendations.py:482 ELK-COMPAT | Before defaults - username: Author Two, display_name: Author Two
INFO     routes.recommendations:recommendations.py:490 ELK-COMPAT | Setting acct to anonymous (was: None)
INFO     routes.recommendations:recommendations.py:496 ELK-COMPAT | After defaults - username: Author Two, display_name: Author Two
ERROR    utils.logging_decorator:logging_decorator.py:61 Error in get_recommended_timeline: name 'request_id' is not defined
ERROR    utils.logging_decorator:logging_decorator.py:62 Traceback (most recent call last):
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/logging_decorator.py", line 50, in decorated_function
    result = f(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^
  File "/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/routes/recommendations.py", line 947, in get_recommended_timeline
    logger.info(f"TIMELINE-{request_id} | First post after build_simple_posts_from_rows:")
                            ^^^^^^^^^^
NameError: name 'request_id' is not defined. Did you mean: 'requests'?

INFO     utils.logging_decorator:logging_decorator.py:66 Request failed: GET /api/v1/recommendations/timelines/recommended in 0.004s
WARNING  app:app.py:189 Request GET /api/v1/recommendations/timelines/recommended completed with status 500 in 0.004232s
____________________ test_recommended_timeline_with_filters ____________________

mock_get_db = <MagicMock name='get_db_connection' id='6068799632'>
client = <FlaskClient <Flask 'app'>>
mock_db_conn = (<MagicMock name='get_db_connection()' id='6081912400'>, <MagicMock name='get_db_connection().cursor()' id='6071539072'>)

    @patch('routes.recommendations.get_db_connection')
    def test_recommended_timeline_with_filters(mock_get_db, client, mock_db_conn):
        """Test getting recommended timeline posts with filters."""
        # Setup mocks
        mock_conn, mock_cursor = mock_db_conn
        mock_get_db.return_value = mock_conn
    
        # Mock database results for SQLite mode
        # First call returns 5 recommendations exist, second call fetches them
        mock_cursor.fetchone.side_effect = [(5,), (5,)]  # 5 recommendations
        mock_cursor.fetchall.return_value = []  # Empty result for simplicity
    
        # Mock USE_IN_MEMORY_DB to be True for SQLite testing
        with patch('routes.recommendations.USE_IN_MEMORY_DB', True):
            # Test with various filters
            response = client.get(
                f'{API_PREFIX}/recommendations/timelines/recommended?user_id=user123&limit=5&min_score=0.7&tags=tech,news&max_id=post999'
            )
    
            # Verify response
            assert response.status_code == 200
    
            # Check that the proper query was constructed with filters
            user_alias = generate_user_alias("user123")
    
            # Verify we called execute with proper parameters
            expected_query_fragments = [
                "WHERE r.user_id = ? AND r.score >= ? AND r.post_id < ?",
                "ORDER BY r.score DESC",
                "LIMIT ?"
            ]
    
            # Get the actual query that was executed
            called_args_list = mock_cursor.execute.call_args_list
    
            # Check if any call contains all our expected fragments
            found_all_fragments = False
            for args, _ in called_args_list:
                query = args[0]
                params = args[1] if len(args) > 1 else None
                if all(fragment in query for fragment in expected_query_fragments):
                    # Check parameters
                    if (params and len(params) >= 4 and
                        params[0] == user_alias and
                        params[1] == 0.7 and
                        params[2] == "post999" and
                        params[3] == 5):
                        found_all_fragments = True
                        break
    
>           assert found_all_fragments, f"Expected SQL query fragments with correct parameters were not found. Queries executed: {[args[0] for args, _ in called_args_list]}"
E           AssertionError: Expected SQL query fragments with correct parameters were not found. Queries executed: ['SELECT COUNT(*) FROM recommendations WHERE user_id = ?', '\n                    SELECT r.post_id, r.score, r.reason, p.content, p.author_id, p.created_at, p.metadata\n                    FROM recommendations r\n                    JOIN posts p ON r.post_id = p.post_id\n                    WHERE r.user_id = ?\n                    ORDER BY r.score DESC\n                    LIMIT ?\n                ']
E           assert False

tests/test_recommendations.py:432: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:28,219 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:28,222 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:28,222 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:28,222 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:28,222 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:28,222 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:28,222 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:28,222 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:28,222 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:28,222 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:28,222 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:28,222 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:28,238 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:28,239 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:28,243 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:28,253 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timelines/recommended
2025-06-12 12:00:28,255 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/timelines/recommended in 0.001s
2025-06-12 12:00:28,255 [INFO] app: Request GET /api/v1/recommendations/timelines/recommended completed with status 200 in 0.001693s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timelines/recommended
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/timelines/recommended in 0.001s
INFO     app:app.py:189 Request GET /api/v1/recommendations/timelines/recommended completed with status 200 in 0.001693s
________________ test_recommended_timeline_parameter_validation ________________

mock_get_db = <MagicMock name='get_db_connection' id='6065217632'>
client = <FlaskClient <Flask 'app'>>
mock_db_conn = (<MagicMock name='get_db_connection()' id='5980316464'>, <MagicMock name='get_db_connection().cursor()' id='6068275488'>)

    @patch('routes.recommendations.get_db_connection')
    def test_recommended_timeline_parameter_validation(mock_get_db, client, mock_db_conn):
        """Test parameter validation for recommended timeline endpoint."""
        # Setup mocks
        mock_conn, mock_cursor = mock_db_conn
        mock_get_db.return_value = mock_conn
    
        # Test with missing required parameter (user_id)
        response = client.get(f'{API_PREFIX}/recommendations/timelines/recommended')
        assert response.status_code == 400
        data = json.loads(response.data)
        assert "Missing required parameter" in data["error"]
    
        # Test with invalid min_score
        response = client.get(f'{API_PREFIX}/recommendations/timelines/recommended?user_id=user123&min_score=1.5')
>       assert response.status_code == 400
E       assert 200 == 400
E        +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code

tests/test_recommendations.py:450: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:28,265 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:28,267 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:28,267 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:28,268 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:28,268 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:28,268 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:28,268 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:28,268 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:28,268 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:28,268 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:28,268 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:28,268 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:28,284 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:28,285 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:28,288 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:28,298 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timelines/recommended
2025-06-12 12:00:28,298 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/timelines/recommended in 0.000s
2025-06-12 12:00:28,298 [WARNING] app: Request GET /api/v1/recommendations/timelines/recommended completed with status 400 in 0.000437s
2025-06-12 12:00:28,299 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timelines/recommended
2025-06-12 12:00:28,301 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/timelines/recommended in 0.002s
2025-06-12 12:00:28,301 [INFO] app: Request GET /api/v1/recommendations/timelines/recommended completed with status 200 in 0.001687s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timelines/recommended
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/timelines/recommended in 0.000s
WARNING  app:app.py:189 Request GET /api/v1/recommendations/timelines/recommended completed with status 400 in 0.000437s
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timelines/recommended
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/timelines/recommended in 0.002s
INFO     app:app.py:189 Request GET /api/v1/recommendations/timelines/recommended completed with status 200 in 0.001687s
___________________ test_recommended_timeline_auto_generate ____________________

mock_get_db = <MagicMock name='get_db_connection' id='5980597248'>
mock_generate_rankings_for_user = <MagicMock name='generate_rankings_for_user' id='6090039920'>
client = <FlaskClient <Flask 'app'>>
mock_db_conn = (<MagicMock name='get_db_connection()' id='5979089056'>, <MagicMock name='get_db_connection().cursor()' id='5979085072'>)

    @patch('core.ranking_algorithm.generate_rankings_for_user')
    @patch('routes.recommendations.get_db_connection')
    def test_recommended_timeline_auto_generate(mock_get_db, mock_generate_rankings_for_user, client, mock_db_conn):
        """Test auto-generation of rankings when none exist."""
        # Setup mocks
        mock_conn, mock_cursor = mock_db_conn
        mock_get_db.return_value = mock_conn
    
        # Mock database with no recommendations
        mock_cursor.fetchone.return_value = (0,)  # No recommendations
        mock_cursor.fetchall.return_value = []  # No results
    
        # Mock the ranking generation
        mock_generate_rankings_for_user.return_value = {
            "message": "Rankings generated successfully",
            "count": 1
        }
    
        # Mock USE_IN_MEMORY_DB to be True for SQLite testing
        with patch('routes.recommendations.USE_IN_MEMORY_DB', True):
            # Make request
            response = client.get(f'{API_PREFIX}/recommendations/timelines/recommended?user_id=user123')
    
            # Verify response code
            assert response.status_code == 200
    
            # Verify rankings were auto-generated
>           assert mock_generate_rankings_for_user.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='generate_rankings_for_user' id='6090039920'>.called

tests/test_recommendations.py:488: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-06-12 12:00:28,310 [INFO] app: Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
2025-06-12 12:00:28,314 [WARNING] utils.metrics: Port 9100 is already in use, metrics server may already be running
2025-06-12 12:00:28,314 [INFO] utils.metrics: Metrics are still being collected and will be exported on port 9100
2025-06-12 12:00:28,314 [INFO] app: Prometheus metrics server started on port 9100
2025-06-12 12:00:28,314 [INFO] db.schema: Creating SQLite in-memory tables...
2025-06-12 12:00:28,314 [INFO] db.schema: Creating SQLite indexes...
2025-06-12 12:00:28,314 [INFO] db.schema: SQLite in-memory database schema created successfully
2025-06-12 12:00:28,315 [INFO] db.connection: In-memory SQLite database schema created successfully
2025-06-12 12:00:28,315 [INFO] db.connection: Seeding in-memory database with test data...
2025-06-12 12:00:28,315 [ERROR] db.connection: Error seeding test data: UNIQUE constraint failed: users.user_id
2025-06-12 12:00:28,315 [INFO] app: Database initialized successfully on startup
2025-06-12 12:00:28,315 [INFO] app: Model registry factory initialized successfully
2025-06-12 12:00:28,331 [INFO] routes.docs: API documentation registered at /api/v1/docs
2025-06-12 12:00:28,332 [INFO] routes.docs: ReDoc documentation registered at /api/v1/docs/redoc
2025-06-12 12:00:28,336 [INFO] app: Setup GUI enabled - registering blueprint at /setup
------------------------------ Captured log setup ------------------------------
INFO     app:app.py:93 Configuring CORS with allowed origins: ['http://localhost:3000', 'http://localhost:5314']
WARNING  utils.metrics:metrics.py:172 Port 9100 is already in use, metrics server may already be running
INFO     utils.metrics:metrics.py:175 Metrics are still being collected and will be exported on port 9100
INFO     app:app.py:118 Prometheus metrics server started on port 9100
INFO     db.schema:schema.py:278 Creating SQLite in-memory tables...
INFO     db.schema:schema.py:282 Creating SQLite indexes...
INFO     db.schema:schema.py:294 SQLite in-memory database schema created successfully
INFO     db.connection:connection.py:147 In-memory SQLite database schema created successfully
INFO     db.connection:connection.py:161 Seeding in-memory database with test data...
ERROR    db.connection:connection.py:244 Error seeding test data: UNIQUE constraint failed: users.user_id
INFO     app:app.py:127 Database initialized successfully on startup
INFO     app:app.py:136 Model registry factory initialized successfully
INFO     routes.docs:docs.py:290 API documentation registered at /api/v1/docs
INFO     routes.docs:docs.py:291 ReDoc documentation registered at /api/v1/docs/redoc
INFO     app:app.py:225 Setup GUI enabled - registering blueprint at /setup
----------------------------- Captured stdout call -----------------------------
2025-06-12 12:00:28,346 [INFO] utils.logging_decorator: Request received: GET /api/v1/recommendations/timelines/recommended
2025-06-12 12:00:28,346 [ERROR] routes.recommendations: Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
2025-06-12 12:00:28,347 [INFO] utils.logging_decorator: Request completed: GET /api/v1/recommendations/timelines/recommended in 0.001s
2025-06-12 12:00:28,347 [INFO] app: Request GET /api/v1/recommendations/timelines/recommended completed with status 200 in 0.001266s
------------------------------ Captured log call -------------------------------
INFO     utils.logging_decorator:logging_decorator.py:39 Request received: GET /api/v1/recommendations/timelines/recommended
ERROR    routes.recommendations:recommendations.py:877 Failed to auto-generate rankings: generate_rankings() takes 0 positional arguments but 1 was given
INFO     utils.logging_decorator:logging_decorator.py:54 Request completed: GET /api/v1/recommendations/timelines/recommended in 0.001s
INFO     app:app.py:189 Request GET /api/v1/recommendations/timelines/recommended completed with status 200 in 0.001266s
____________________ test_get_author_preference_score_exact ____________________

mock_get_cursor = <MagicMock name='get_cursor' id='6065347936'>
mock_get_db = <MagicMock name='get_db_connection' id='6065342176'>

    @patch("core.ranking_algorithm.get_db_connection")
    @patch("core.ranking_algorithm.get_cursor")
    def test_get_author_preference_score_exact(mock_get_cursor, mock_get_db):
        """Ensure get_author_preference_score follows the documented logistic formula exactly."""
    
        # --------------------------------------------------
        # Prepare dummy DB plumbing so that the internal SQL
        # query that maps post_id -> author_id returns the
        # mapping we control.
        # --------------------------------------------------
        cursor = _DummyCursor()
        # Each tuple is (post_id, author_id)
        cursor.fetchall.return_value = [
            ("p1", "authorX"),
            ("p2", "authorX"),
            ("p3", "authorX"),
        ]
    
        # get_cursor returns our cursor *as a context manager*
        mock_get_cursor.side_effect = lambda conn: cursor
    
        # get_db_connection yields a dummy connection that does nothing
        mock_get_db.return_value = _DummyConnection()
    
        # Three positive interactions for authorX, zero negatives
        interactions = [
            {"post_id": "p1", "action_type": "favorite"},
            {"post_id": "p2", "action_type": "reblog"},
            {"post_id": "p3", "action_type": "favorite"},
        ]
    
        # According to the implementation the logistic formula is:
        # preference_score = 1 / (1 + exp(-5 * (positive_ratio - 0.5)))
        positive_ratio = 3 / 3  # 1.0
        expected_score = 1 / (1 + math.exp(-5 * (positive_ratio - 0.5)))
    
        score = get_author_preference_score(interactions, "authorX")
    
>       assert math.isclose(score, expected_score, rel_tol=1e-6)
E       assert False
E        +  where False = <built-in function isclose>(0.1, 0.9241418199787566, rel_tol=1e-06)
E        +    where <built-in function isclose> = math.isclose

tests/test_scoring_exact.py:80: AssertionError
_________________________ test_get_recency_score_exact _________________________

    def test_get_recency_score_exact():
        """Ensure recency score obeys exp(-age_days / decay_factor)."""
>       from config import ALGORITHM_CONFIG
E       ImportError: cannot import name 'ALGORITHM_CONFIG' from '<unknown module name>' (unknown location)

tests/test_scoring_exact.py:104: ImportError
=============================== warnings summary ===============================
core/model_registry.py:325
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/core/model_registry.py:325: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    now = datetime.utcnow()

db/models.py:21
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/db/models.py:21: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

tests/test_load_testing_framework.py:182
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_load_testing_framework.py:182: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/test_performance_monitoring.py:271
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_monitoring.py:271: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/test_db.py::test_record_and_get_interaction
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/db/crud.py:48: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    timestamp=timestamp or datetime.utcnow()

tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_missing_user_id
tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_successful_fresh_timeline
tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_no_recommendations_returns_404
tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_error_handling
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_fresh_timeline.py:36: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'token_expires_at': (datetime.utcnow() + timedelta(hours=6)).isoformat()

tests/test_load_testing_framework.py::TestLoadTestingIntegration::test_baseline_load_test_execution
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/load_testing_framework.py:380: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    start_time=datetime.utcnow(),

tests/test_load_testing_framework.py::TestLoadTestingIntegration::test_baseline_load_test_execution
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/load_testing_framework.py:381: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    end_time=datetime.utcnow(),

tests/test_load_testing_framework.py::TestLoadTestingIntegration::test_baseline_load_test_execution
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/load_testing_framework.py:430: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    test_elapsed = (datetime.utcnow() - result.start_time).total_seconds()

tests/test_load_testing_framework.py::TestLoadTestingIntegration::test_baseline_load_test_execution
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/load_testing_framework.py:396: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    result.end_time = datetime.utcnow()

tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_no_token_data
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_empty_recommendations
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_successful_fresh_fetch
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_cache_hit_scenario
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_token_refresh_success
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_token_refresh_failure
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_missing_post_omitted
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_custom_cache_ttl
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_mastodon_api.py:211: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'token_expires_at': datetime.utcnow() + timedelta(hours=1),

tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_successful_fresh_fetch
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_successful_fresh_fetch
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_mastodon_api.py:251: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "created_at": datetime.utcnow().isoformat()

tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_successful_fresh_fetch
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_successful_fresh_fetch
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_missing_post_omitted
tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_custom_cache_ttl
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/mastodon_api.py:232: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'fetched_at': datetime.utcnow().isoformat()

tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_token_refresh_success
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_mastodon_api.py:304: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    expired_token_data['token_expires_at'] = datetime.utcnow() - timedelta(hours=1)

tests/test_mastodon_api.py::TestFetchFreshMastodonStatuses::test_token_refresh_failure
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_mastodon_api.py:332: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    expired_token_data['token_expires_at'] = datetime.utcnow() - timedelta(hours=1)

tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_instance_timelines
tests/test_multi_source_discovery.py::TestMultiSourceIntegration::test_end_to_end_discovery_workflow
tests/test_multi_source_discovery.py::TestMultiSourceIntegration::test_end_to_end_discovery_workflow
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/opt_out_service.py:59: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'timestamp': datetime.utcnow()

tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_instance_timelines
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_hashtag_streams
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_hashtag_streams
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_hashtag_streams
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_follow_relationships
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_follow_relationships
tests/test_multi_source_discovery.py::TestContentDiscoveryEngine::test_discover_from_follow_relationships
tests/test_multi_source_discovery.py::TestMultiSourceIntegration::test_end_to_end_discovery_workflow
tests/test_multi_source_discovery.py::TestMultiSourceIntegration::test_end_to_end_discovery_workflow
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/opt_out_service.py:38: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    if datetime.utcnow() - cached_data['timestamp'] < _cache_ttl:

tests/test_performance_api.py::TestGetBenchmarks::test_get_benchmarks_success
tests/test_performance_api.py::TestGetBenchmarkDetails::test_get_benchmark_details_success
tests/test_performance_api.py::TestCompareBenchmarks::test_compare_benchmarks_success
tests/test_performance_api.py::TestStatsAndExport::test_export_benchmarks_csv
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_api.py:47: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'test_timestamp': datetime.utcnow(),

tests/test_performance_api.py::TestGetBenchmarks::test_get_benchmarks_success
tests/test_performance_api.py::TestGetBenchmarkDetails::test_get_benchmark_details_success
tests/test_performance_api.py::TestCompareBenchmarks::test_compare_benchmarks_success
tests/test_performance_api.py::TestStatsAndExport::test_export_benchmarks_csv
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_api.py:72: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'test_timestamp': datetime.utcnow() - timedelta(days=1),

tests/test_performance_api.py::TestGetPerformanceTrends::test_get_trends_success
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_api.py:251: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    (datetime.utcnow() - timedelta(days=1), 95.0, 16.5, 0.01),

tests/test_performance_api.py::TestGetPerformanceTrends::test_get_trends_success
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_api.py:252: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    (datetime.utcnow(), 100.0, 16.0, 0.015)

tests/test_performance_api.py::TestGetRegressionReports::test_get_regressions_success
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_api.py:102: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'detection_timestamp': datetime.utcnow(),

tests/test_performance_api.py::TestMonitoringEndpoints::test_get_monitoring_status_success
tests/test_performance_api.py::TestMonitoringEndpoints::test_create_monitoring_snapshot_success
tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_performance_summary
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_monitoring.py:826: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'timestamp': datetime.utcnow().isoformat(),

tests/test_performance_api.py: 16 warnings
tests/test_performance_monitoring.py: 12 warnings
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_monitoring.py:214: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    window_start = datetime.utcnow() - timedelta(minutes=window_minutes)

tests/test_performance_api.py::TestMonitoringEndpoints::test_create_monitoring_snapshot_success
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_monitoring.py:873: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    datetime.utcnow(),

tests/test_performance_gates.py::TestGateEvaluation::test_gate_evaluation_creation
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_gates.py:160: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    evaluation_timestamp=datetime.utcnow(),

tests/test_performance_monitoring.py: 30 warnings
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_monitoring.py:187: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    timestamp=datetime.utcnow(),

tests/test_performance_monitoring.py::TestMetricCollector::test_metric_aggregation
tests/test_performance_monitoring.py::TestThresholdMonitor::test_violation_detection
tests/test_performance_monitoring.py::TestThresholdMonitor::test_alert_generation
tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_performance_summary
tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_performance_summary
tests/test_performance_monitoring.py::TestPerformanceMonitoringIntegration::test_end_to_end_monitoring_workflow
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_monitoring.py:240: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    window_end=datetime.utcnow(),

tests/test_performance_monitoring.py::TestThresholdMonitor::test_violation_detection
tests/test_performance_monitoring.py::TestThresholdMonitor::test_alert_generation
tests/test_performance_monitoring.py::TestPerformanceMonitoringIntegration::test_end_to_end_monitoring_workflow
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_monitoring.py:309: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    current_time = datetime.utcnow()

tests/test_performance_monitoring.py::TestNotificationManager::test_notification_processing
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_monitoring.py:140: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    self.timestamp = timestamp or datetime.utcnow()

tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_error_rate_calculation
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_monitoring.py:728: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    since=datetime.utcnow() - timedelta(minutes=window_minutes))

tests/test_performance_monitoring.py::TestPerformanceMonitoringSystem::test_error_rate_calculation
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_monitoring.py:730: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    since=datetime.utcnow() - timedelta(minutes=window_minutes))

tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_get_benchmark_data
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_regression_detection.py:161: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    mock_cursor.fetchone.return_value = (1, 'test_benchmark', datetime.utcnow(), 100.0, 150.0, 1000.0, 0.01)

tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_detect_regressions_basic
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_regression_detection.py:61: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'test_timestamp': datetime.utcnow() - timedelta(days=1),

tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_detect_regressions_basic
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_regression_detection.py:74: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    'test_timestamp': datetime.utcnow(),

tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_detect_regressions_basic
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_detect_regressions_basic
tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_detect_regressions_basic
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_regression_detection.py:367: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    detection_timestamp=datetime.utcnow(),

tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_detect_regressions_basic
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/utils/performance_regression_detection.py:277: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    detection_timestamp=datetime.utcnow(),

tests/test_performance_regression_detection.py::TestPerformanceRegressionDetector::test_generate_regression_report
  /Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/tests/test_performance_regression_detection.py:223: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    detection_timestamp=datetime.utcnow(),

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html

---------- coverage: platform darwin, python 3.12.1-final-0 ----------
Name                                             Stmts   Miss  Cover   Missing
------------------------------------------------------------------------------
__init__.py                                          0      0   100%
agents/__init__.py                                   1      0   100%
agents/agent_config.py                             200    200     0%   7-380
agents/agent_launcher.py                           116    116     0%   7-295
agents/browser_agent.py                            341    234    31%   18-19, 50-53, 73, 78-83, 86-92, 191, 206, 229-435, 478, 506, 511, 532-533, 540-565, 570-574, 608-622, 634-692, 708-789, 805-863, 879-952, 970-1028
agents/claude_interface.py                         112     99    12%   20-50, 60-80, 107-184, 207-271, 283-306
agents/core_agent_system.py                        474    474     0%   7-1273
agents/feedback_module.py                          134     77    43%   84-85, 136-137, 180-212, 223-241, 253-271, 283-349, 360-375
agents/interaction_logger.py                        71     27    62%   87, 93-94, 122-150, 162-163, 176-186
agents/test_all_features.py                        128    128     0%   15-295
agents/test_runner.py                              392    392     0%   3-782
agents/token_tracker.py                            105     12    89%   191-196, 279-288
agents/user_profiles.py                            326    224    31%   44, 55, 69, 89, 104-128, 178, 180, 184, 246-284, 308, 314-332, 381-420, 431-472, 483-542, 556-598, 637-675, 686-722, 745-748, 762-774, 778-784, 800-831, 872-934, 946-974, 985-1023, 1037-1064, 1102-1119, 1131-1138, 1153-1168, 1192-1193, 1206-1214, 1231-1240
agents/web_agent_dashboard.py                       80     80     0%   7-565
app.py                                             207     79    62%   55-71, 85-88, 119-120, 128-129, 137-138, 181, 228, 243-244, 258, 287, 337, 360-369, 385-428, 435-449, 474-477, 492-520, 530-576, 584-588, 617, 633-634, 646-648
check-recs-simple.py                                69     69     0%   7-143
check_crawl_progress.py                             18     18     0%   2-31
check_crawled_posts.py                              35     35     0%   4-63
check_db.py                                         15     15     0%   2-19
check_db_data.py                                    20     20     0%   2-34
check_null_data.py                                  27     27     0%   2-44
check_post_urls.py                                  16     16     0%   2-34
config.py                                          109     10    91%   79, 84-91, 96-101, 114
core/__init__.py                                     0      0   100%
core/model_registry.py                             403    249    38%   210-212, 230-253, 257-258, 302, 305, 309, 321-322, 349-362, 399, 416-451, 455-462, 481-503, 507-535, 541, 545-563, 567-578, 585-588, 592-604, 608-613, 617-633, 656-690, 694-718, 730-756, 760-780, 790-834, 839-857, 861-866, 870-898
core/ranking_algorithm.py                          249     85    66%   38-76, 107, 164-168, 194-204, 250, 266-267, 274-276, 338-339, 366, 373-375, 381-382, 456, 459, 462, 465, 471-472, 485, 489, 494-495, 530-536, 564-567, 576-637
core/recommender_base.py                           208    112    46%   111, 123-160, 169-182, 186, 190, 194, 203-208, 217-239, 271, 282-290, 302, 307, 312, 323-331, 344, 358, 368-382, 394-440, 450-451, 469, 479, 498-509, 521
core/recommender_factory.py                        124     85    31%   71, 101-129, 133-135, 148-162, 195-227, 250-279, 302-312, 325-339, 360, 384, 398-399, 422-442, 465-466, 475-482
db/__init__.py                                       0      0   100%
db/connection.py                                   125     22    82%   41-43, 62-67, 92, 95-96, 112, 134-136, 208, 217-219, 271-272
db/connection_pool.py                              248    193    22%   103-130, 134-144, 148-155, 159-170, 174-234, 238, 251-282, 292-310, 319-335, 339-357, 366-372, 385-401, 424-442, 451, 466-478, 484-487, 498-501
db/crud.py                                         115     72    37%   53-56, 88, 91, 94, 98-99, 129, 132, 135, 139-140, 174-195, 208-213, 231-241, 259-278, 296-317, 335-380
db/models.py                                       374    116    69%   82-91, 260-264, 297, 301, 305, 309, 313, 317, 322, 326, 330-336, 340-342, 347-352, 356-358, 362-369, 373, 377-401, 405-410, 414, 419-459, 475, 480-486, 491-497, 502, 528, 532-535, 539, 560, 565, 587, 591, 612, 632, 636, 640-647, 651-653
db/privacy.py                                       60     41    32%   30, 34, 54-75, 87, 99-114, 126-127, 140-153, 166-177, 189-195
db/recommendations.py                              145    119    18%   34-109, 133-208, 216-241, 245-257, 262-322, 335-349, 362-394, 403-419
db/schema.py                                        72     52    28%   129-140, 150-157, 170-198, 306-356
db/session.py                                       96     30    69%   51-52, 59-72, 91-93, 96-98, 120-121, 140-147, 164-171
db/setup.py                                         74     74     0%   13-143
debug_ensure_elk.py                                 20     20     0%   2-41
debug_ensure_elk_detailed.py                        27     27     0%   2-74
debug_row_lengths.py                                27     27     0%   2-47
debug_timeline_query.py                             27     27     0%   2-60
debug_url_format.py                                 22     22     0%   2-29
enhance_api.py                                       9      9     0%   1-61
fresh_crawl.py                                     165    165     0%   7-388
fresh_crawl_with_realtime.py                       103    103     0%   7-271
load_mastodon_posts.py                              57     57     0%   7-111
log_entry.py                                       133    133     0%   33-280
minimal_api.py                                      25     25     0%   2-295
quick_api_test.py                                   35     35     0%   2-56
routes/__init__.py                                   1      0   100%
routes/analytics.py                                252    211    16%   48-120, 145-147, 161-163, 171-173, 190-301, 329-433, 464-635, 650-719, 734-781, 799-858
routes/content_discovery.py                         81     34    58%   59-60, 136-137, 151-201, 220-285, 294, 302
routes/docs.py                                      52     14    73%   72-73, 76-78, 89-124, 135-247, 260-263, 288
routes/fastapi_example.py                           85     85     0%   9-325
routes/feedback.py                                  85     70    18%   44-152, 169-233
routes/health.py                                    51     14    73%   61-65, 92-119
routes/interactions.py                             270    105    61%   27-44, 73, 155, 158, 185, 233, 257-411, 476, 512-514, 519, 527-610, 629, 674, 715-722, 725, 763, 786, 817-846
routes/model_registry.py                           242    188    22%   48-86, 110-185, 196-238, 252-286, 308-346, 355-365, 386-440, 457-509, 532-566, 575-585
routes/oauth.py                                     93     60    35%   35-37, 44-53, 57-60, 64-74, 90-128, 147-175, 198-214, 232-250
routes/performance.py                              299     89    70%   66, 69, 80-81, 84-85, 151, 167, 181-183, 209, 221, 232, 244-245, 276-278, 316, 331-338, 375-389, 411, 434, 448-450, 475, 484, 497, 512-514, 523-531, 536-553, 586, 595-610, 616, 644, 654-657, 672-674, 723, 732-734, 761, 778-785, 794, 802
routes/posts.py                                    207    106    49%   53, 101-147, 150-153, 189, 239, 268-315, 364, 384-413, 468, 477-485, 568-623, 626-629, 645-746
routes/privacy.py                                   47      2    96%   87, 107
routes/proxy.py                                    639    357    44%   60-61, 79-80, 101-102, 127-128, 139-142, 159, 170-171, 178-179, 190-195, 198-200, 221-238, 266, 273-280, 291-294, 331-337, 368-373, 389-401, 415-448, 464-465, 468-469, 481, 500, 506, 547-777, 824-852, 886-895, 926-927, 935-946, 973-975, 1029-1095, 1102-1105, 1140-1186, 1194-1271, 1292, 1315, 1359-1406, 1421-1476, 1502-1525, 1550, 1607-1610, 1628, 1655-1663, 1693-1694, 1740, 1753-1761
routes/recommendations.py                          755    481    36%   60-62, 78-139, 144-150, 155-161, 166-248, 253-327, 332-354, 369-429, 439, 452, 478, 485, 487-488, 493-494, 520-522, 548-683, 711, 750-793, 807-808, 826-828, 908-909, 948-951, 956-1111, 1187-1251, 1313, 1321-1322, 1328-1363, 1423-1437, 1457-1487, 1509-1559, 1582, 1590, 1593-1594, 1597, 1629-1633, 1642-1702, 1720-1721, 1723-1724, 1726-1733, 1742-1743, 1752-1753, 1759-1763, 1771-1775, 1784-1907, 1916-2036
routes/setup_gui.py                                146    113    23%   30, 38-50, 58-64, 72-79, 87-200, 208-242, 250-268, 282-285, 294-303
routes/timeline.py                                 325    135    58%   69-90, 123-147, 182-185, 201-204, 219-275, 296-308, 322, 377-380, 412, 414, 442-443, 544-553, 565-581, 587-590, 617-618, 622-623, 644-647, 653-654, 660-675, 695-705, 727-741, 782-823
routes/users.py                                     40     14    65%   92-139
run_proxy_server.py                                110     84    24%   37, 43-105, 120-144, 148-198, 201
run_scalability_tests.py                            83     83     0%   6-198
run_server.py                                       96     63    34%   62, 82-106, 119-131, 135-192
simple_api_test.py                                  15     15     0%   2-27
simple_http_proxy.py                                40     40     0%   7-77
simple_timeline_test.py                             29     29     0%   5-110
special_proxy.py                                   289    231    20%   43-46, 55-56, 61-63, 67-95, 102-131, 138-152, 159, 170-173, 186-189, 201-233, 240-268, 286, 297-301, 332-344, 351-416, 427-515, 533, 540-555, 581-605, 609-690
tasks/content_crawler.py                           579    298    49%   139-142, 195-206, 213-216, 234, 264-267, 279-281, 335-337, 351-353, 381-383, 388, 395, 421-423, 469-529, 566-599, 616-618, 644-695, 721-722, 763-765, 792, 796, 835, 837, 841, 852, 883-940, 962-963, 1024-1026, 1053-1168, 1189-1357, 1372-1436, 1448, 1467-1471, 1484-1485, 1560-1562, 1567-1577
tasks/database_cleanup.py                          320    159    50%   19-20, 98-175, 224-227, 242-327, 382-405, 415-459, 473-474, 479, 483-490, 532-537, 548-553, 564-569, 583-584, 589-596, 616-619, 638-639, 673-693, 710-713, 732-737, 741-743
tasks/exceptions.py                                 49     24    51%   32-33, 39-40, 46-47, 53-54, 65-66, 71-82, 87, 92-94
tasks/performance_gates_worker.py                  134     67    50%   43-44, 49-50, 61, 81-88, 100-105, 123-133, 141-180, 198-204, 220-223, 230-231, 238-241, 249-288
tasks/ranking_tasks.py                             203    188     7%   72-498, 514-608
tasks/validation.py                                 29     21    28%   14-18, 24-28, 33-51, 57-61, 67
test-elk-connection.py                             189    189     0%   7-295
test_analysis.py                                    56     56     0%   1-73
test_api_simple.py                                  45     45     0%   5-82
test_build_function.py                              37     37     0%   2-64
test_query.py                                       26     26     0%   2-46
test_timeline_api.py                                27     27     0%   4-42
test_timeline_direct.py                             33     33     0%   2-56
test_timeline_elk.py                                59     59     0%   5-92
test_timeline_endpoint.py                           34     34     0%   6-65
test_user_personalization.py                        35     35     0%   7-60
tests/__init__.py                                    0      0   100%
tests/comprehensive_stress_test.py                 597    597     0%   18-1202
tests/config_tests/test_cli_args.py                 78      1    99%   199
tests/conftest.py                                   58      9    84%   45-75
tests/db_test_helper.py                            146    146     0%   12-271
tests/locustfile_recommendations.py                193    193     0%   15-424
tests/monitor_stress_test.py                       105    105     0%   8-163
tests/quick_oauth_test.py                           29     29     0%   4-49
tests/quick_test.py                                 15     15     0%   4-26
tests/run_cache_tests.py                             7      7     0%   6-18
tests/simple_auth_test.py                           71     71     0%   6-134
tests/simple_test_server.py                         13     13     0%   4-20
tests/test_ab_analysis.py                          153    117    24%   24-173, 185-240, 270-282, 289-316, 319
tests/test_ab_performance.py                       141     98    30%   27-68, 72-118, 133-139, 156-159, 181, 185-186, 190-211, 215-235, 239-285, 288
tests/test_agent_features.py                       149     77    48%   34-36, 41-51, 115-117, 140-177, 200-202, 229-269, 274-316, 320
tests/test_all_features.py                         149     77    48%   34-36, 41-53, 117-119, 140-177, 200-202, 229-271, 276-320, 324
tests/test_api_caching.py                           96      0   100%
tests/test_api_flow.py                             305     54    82%   94-114, 116-119, 121-124, 127-130, 133-136, 163, 166-167, 170-175, 178-179, 289-302, 501, 673-683, 761-762
tests/test_api_recommendations_timeline.py          35      7    80%   12, 15, 63-69
tests/test_async_recommendations.py                197     72    63%   59-64, 71-88, 113-116, 132-133, 147-152, 169-176, 190-193, 210-211, 218-241, 250-251, 271, 274-301
tests/test_authentication.py                       200      0   100%
tests/test_caching_system.py                       203      1    99%   47
tests/test_celery_integration.py                    65      9    86%   72-73, 97-101, 104-105
tests/test_connection_pool.py                      133     80    40%   69-81, 86-104, 108-111, 115-124, 128-137, 141-151, 155, 160-169, 174-185, 194-200, 204-221, 225-245, 249-262, 266-284
tests/test_content_crawler.py                      153      2    99%   302-303
tests/test_crawled_posts_table.py                    9      2    78%   6-7
tests/test_database_cleanup.py                     117      3    97%   241-242, 246
tests/test_db.py                                    51     13    75%   52, 64-65, 74-75, 84, 88-96, 99
tests/test_db_connection.py                         72      2    97%   15, 84
tests/test_empty_timeline.py                        54      7    87%   125-133
tests/test_fresh_timeline.py                        75     16    79%   44-45, 72-84, 120-123, 151-152, 156
tests/test_health.py                                34      0   100%
tests/test_integration.py                          140     23    84%   109-124, 182-192, 209-211, 325-339, 343
tests/test_interactions.py                         124      0   100%
tests/test_interactions_security.py                 62      4    94%   42-44, 196
tests/test_language_aware_trending.py              205     17    92%   199-257, 421
tests/test_load_testing_framework.py               107      1    99%   221
tests/test_mastodon_api.py                         174      0   100%
tests/test_metrics.py                               73     65    11%   16-131, 134
tests/test_metrics_extended.py                      73     65    11%   17-153, 157
tests/test_multi_source_discovery.py               205      7    97%   287-290, 317, 322, 418
tests/test_openapi_compliance.py                   133     16    88%   47-48, 70-83, 165, 176, 263
tests/test_performance_api.py                      186      1    99%   397
tests/test_performance_benchmarks.py               177      1    99%   43
tests/test_performance_gates.py                     84      0   100%
tests/test_performance_monitoring.py               177     15    92%   306-327
tests/test_performance_monitoring_complete.py      211     95    55%   40-67, 76-79, 106, 115, 133, 137-178, 223-266, 278-294, 298-300, 312-317, 322-323, 402, 405-406, 426-430, 437-450, 468-470, 473
tests/test_performance_regression_detection.py     110      0   100%
tests/test_posts.py                                111      6    95%   44-54, 87, 248-249
tests/test_privacy.py                               65      0   100%
tests/test_privacy_routes.py                        65      0   100%
tests/test_proxy.py                                139      1    99%   267
tests/test_proxy_caching.py                         67      1    99%   139
tests/test_quality_metrics.py                       85     51    40%   25-83, 97-101, 110-113, 119-123, 142-144, 148-176, 179
tests/test_ranking_algorithm.py                    167     19    89%   147-163, 373-379
tests/test_ranking_pipeline_integration.py          39      4    90%   87-91
tests/test_rate_limiting_integration.py            103      7    93%   154, 165-169, 212
tests/test_rbac_functionality.py                   119     71    40%   42-58, 72-80, 86-112, 135-148, 173-176, 190-194, 201-237, 240
tests/test_recommendation_engine.py                 81      0   100%
tests/test_recommendations.py                      219     26    88%   61, 114, 269, 353-379, 424-430, 451-458, 491-496
tests/test_responsible_crawling.py                  70      1    99%   144
tests/test_scoring_exact.py                         47     11    77%   22, 25, 32, 35, 106-115
tests/test_security_interactions.py                 59      4    93%   145-148, 152
tests/test_throttling.py                            30      2    93%   42, 61
tests/test_timeline.py                              88     21    76%   13-21, 75-77, 81-82, 137-158
tests/test_timeline_injection.py                    57      6    89%   138-145
tests/test_timeline_injector.py                     75      2    97%   37, 187
tests/test_token_management.py                      78      2    97%   37, 198
timeline_api_real.py                                50     50     0%   6-148
utils/__init__.py                                    1      0   100%
utils/ab_analysis.py                               289    193    33%   114-172, 190-194, 212-297, 302-314, 328-340, 344-354, 359-406, 420-433, 437, 442-517, 522-552, 556-591, 595-646
utils/ab_performance.py                            182     67    63%   31-33, 119-120, 146, 162-184, 227-244, 281-308, 316-342, 346-350, 355-383, 396-441
utils/ab_testing.py                                190    143    25%   47-110, 126-139, 147-168, 174-197, 201-232, 236-262, 266-285, 289-307, 311-324, 337-359, 386-413, 422-424, 428-443, 461-469
utils/auth.py                                      118    104    12%   25-46, 60-104, 118-139, 152-170, 183-243
utils/baseline_kpi_measurement.py                  373    316    15%   62-64, 68, 91-116, 120-226, 230-268, 272-332, 336-390, 394-456, 462-469, 473-487, 491-505, 510-531, 535-569, 573-593, 598-618, 622-651, 656-693, 697-704, 708-725, 729-751, 755-803, 807-813
utils/cache.py                                     328    179    45%   98-101, 113-128, 173, 179-181, 231-232, 266-271, 283-299, 365-379, 393-396, 408-409, 424, 440-441, 453-454, 468-469, 483-485, 498-500, 514, 530-531, 543-544, 558-559, 572-573, 585-586, 600-601, 617-618, 630-631, 649-653, 666-670, 682-691, 706-717, 729-754, 766-776, 785-793, 809-810, 822-823, 838-839, 852-853, 867-868, 880-882, 895-896, 909-913, 926-927, 936-937
utils/celery_app.py                                 31     14    55%   40-48, 80-86, 93
utils/follows.py                                    36     36     0%   8-114
utils/input_sanitization.py                        135     34    75%   61-62, 103-104, 108-109, 129, 135-139, 162, 165-167, 186, 189, 195-198, 202-203, 230-231, 235-236, 256, 285-288, 293, 323
utils/instance_health_monitor.py                   185     41    78%   114, 125-126, 203, 213-217, 226, 247-248, 284, 288-290, 300, 310-353
utils/language_detector.py                         115     27    77%   59, 63, 67, 71, 76, 84, 126-128, 133-135, 140-142, 147, 203, 216-225, 238, 258
utils/load_test_integration.py                     272    272     0%   19-750
utils/load_testing_framework.py                    388    139    64%   155-168, 189-191, 202, 252-254, 329-331, 368, 406, 435-484, 512, 514, 516, 518, 535-536, 554-572, 577-578, 584-606, 612-623, 629-640, 644-697, 722, 737, 752, 784-847
utils/logging_decorator.py                          30      0   100%
utils/mastodon_api.py                              120     24    80%   67-68, 73-78, 104-107, 129-132, 180-181, 188-189, 260-263
utils/mastodon_client.py                           270    140    48%   82-85, 89, 99, 148-150, 159-160, 163-174, 183-185, 199, 230-232, 264-284, 297-321, 334-343, 355-363, 379-410, 423-465, 477-510, 525, 531-533, 583-585, 599, 606-621
utils/metrics.py                                   128     56    56%   132-150, 180-181, 185-206, 289, 299, 325-347, 380, 391, 405-414, 450
utils/opt_out_service.py                            48     24    50%   30, 53-54, 77-90, 99-102, 113-114, 124-137
utils/performance_benchmarking.py                  246    213    13%   42-69, 84-125, 139-219, 223-296, 300-341, 346-399, 403-414, 418-459, 463-483, 487-504, 508-542, 546-571, 575-583, 587-602
utils/performance_gates.py                         286    182    36%   149-181, 186-242, 256, 272, 276, 289, 293, 297, 302-377, 381-393, 397-419, 423-461, 465-487, 491-519, 523-558, 562-590, 594-611, 617-642, 647-684, 709-713, 717-729, 733-766, 800
utils/performance_monitoring.py                    452    159    65%   65, 71-80, 102-109, 207, 225, 253-254, 258-265, 296-297, 316, 372-381, 399-401, 421, 425, 452-453, 457-459, 463-465, 469, 473-481, 611-639, 643-668, 681-682, 697-706, 712-713, 722, 734-736, 744, 752-769, 773-789, 793-821, 883-885, 911-947
utils/performance_regression_detection.py          456    162    64%   47, 50-53, 58-65, 223, 227, 231, 242, 298-300, 310-311, 314-315, 372-374, 387, 399, 401, 403, 405, 414, 419, 428-430, 443-456, 471-473, 486-508, 536, 554-555, 625-627, 639-649, 664-666, 693, 700, 706-708, 713, 722, 724, 736-738, 743-745, 756, 763, 767, 789-794, 798-816, 837, 856-858, 879-905, 912-934, 944-979, 999-1042
utils/privacy.py                                    45      9    80%   30-45, 131
utils/rate_limiting.py                              68     54    21%   21-35, 44-55, 60-65, 69-72, 76-79, 83-86, 90-93, 97-100, 104-107, 111-114
utils/rbac.py                                       84     66    21%   56-77, 89-91, 103-110, 123-130, 143-147, 159-172, 184-201, 213-230, 239, 251-254, 266-269
utils/recommendation_engine.py                     142     45    68%   45-51, 134-136, 147-150, 178-180, 186, 213-223, 263-282, 297-304, 364-365, 405-408
utils/recommendation_metrics.py                    283    232    18%   46-49, 64-120, 135-195, 211-298, 315-367, 388-473, 485-548, 584, 589-628, 665, 670
utils/rehydration_service.py                       157    129    18%   43-45, 57-59, 75-97, 102, 116-177, 190-228, 244-272, 277-313, 318-339
utils/request_throttling.py                        306    142    54%   115, 119-124, 139-142, 146-151, 159-167, 185-190, 219-220, 250-255, 262, 265, 274, 285, 287, 295-307, 312, 322, 341-345, 352-357, 361-370, 378-383, 394-398, 409-415, 454-456, 461, 477-522, 527-560, 564-594
utils/timeline_injector.py                         167     36    78%   26-30, 78-90, 138-147, 172-175, 179, 215, 217, 219, 223, 227, 298-299, 310-314, 341, 378
utils/token_refresh.py                             140    126    10%   26-52, 65-79, 92-123, 135-161, 175-248, 262-284, 296-324, 336-392
utils/user_signals.py                              220    184    16%   63-71, 88-98, 120-193, 210-253, 274-366, 385-429, 448-462, 483-487, 501-518, 531-600, 613-664
------------------------------------------------------------------------------
TOTAL                                            26175  14139    46%

=========================== short test summary info ============================
FAILED tests/test_api_recommendations_timeline.py::test_recommendations_timeline_endpoint - assert (True and 0 > 0)
 +  where True = isinstance([], list)
 +  and   0 = len([])
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_recommendations_sync_fallback - AssertionError: assert 'source' in {'debug_info': {'error_occurred': True}, 'message': 'Unable to generate recommendations at this time', 'recommendations': [], 'user_id': 'test_user'}
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_recommendations_parameters_validation - assert 200 == 400
 +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_async_task_queuing - AttributeError: <module 'routes.recommendations' from '/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/routes/recommendations.py'> does not have the attribute 'generate_rankings_async'
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_status_endpoint - KeyError: 'state'
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_status_pending - KeyError: 'state'
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_status_failure - assert 200 == 500
 +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_cancellation - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_task_cancel_completed - assert 404 == 410
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_async_unavailable_fallback - assert 200 == 503
 +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_hybrid_cache_behavior - AttributeError: <module 'routes.recommendations' from '/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/routes/recommendations.py'> does not have the attribute 'generate_rankings_async'
FAILED tests/test_async_recommendations.py::TestAsyncRecommendations::test_processing_time_tracking - AssertionError: assert 'processing_time_ms' in {'debug_info': {'error_occurred': True}, 'message': 'Unable to generate recommendations at this time', 'recommendations': [], 'user_id': 'test_user'}
FAILED tests/test_async_recommendations.py::TestAsyncIntegration::test_end_to_end_async_flow - AttributeError: <module 'routes.recommendations' from '/Users/andrewnordstrom/Elk_Corgi/corgi-recommender-service/routes/recommendations.py'> does not have the attribute 'generate_rankings_async'
FAILED tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_missing_user_id - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_successful_fresh_timeline - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_no_recommendations_returns_404 - TypeError: 'NoneType' object is not subscriptable
FAILED tests/test_fresh_timeline.py::TestFreshTimelineEndpoint::test_error_handling - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_integration.py::test_recommendation_caching - assert 400 in [200, 401]
 +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
FAILED tests/test_integration.py::test_complete_user_journey - assert 400 in [200, 401]
 +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
FAILED tests/test_multi_source_discovery.py::TestEnhancedPostStorage::test_store_crawled_post_enhanced - json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
FAILED tests/test_openapi_compliance.py::TestOpenAPICompliance::test_recommendations_endpoint_compliance - assert 400 in [200, 401]
 +  where 400 = <WrapperTestResponse streamed [400 BAD REQUEST]>.status_code
FAILED tests/test_posts.py::test_get_posts - assert 0 == 10
FAILED tests/test_posts.py::test_get_posts_with_mastodon_data - assert 0 == 42
FAILED tests/test_posts.py::test_get_trending_posts - assert 0 == 100
FAILED tests/test_ranking_algorithm.py::test_generate_rankings_for_user - assert 0 > 0
 +  where 0 = len([])
FAILED tests/test_ranking_pipeline_integration.py::test_generate_rankings_for_user_order - assert 0 == 2
 +  where 0 = len([])
FAILED tests/test_rbac_functionality.py::test_database_schema - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: roles
[SQL: SELECT count(*) AS count_1 
FROM (SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS roles_description, roles.is_system_role AS roles_is_system_role, roles.is_active AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at 
FROM roles) AS anon_1]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FAILED tests/test_rbac_functionality.py::test_user_creation_and_role_assignment - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: roles
[SQL: SELECT roles.id AS roles_id, roles.name AS roles_name, roles.display_name AS roles_display_name, roles.description AS roles_description, roles.is_system_role AS roles_is_system_role, roles.is_active AS roles_is_active, roles.created_at AS roles_created_at, roles.updated_at AS roles_updated_at 
FROM roles 
WHERE roles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('admin', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FAILED tests/test_rbac_functionality.py::test_permission_checking - sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: user_roles
[SQL: SELECT user_roles.id AS user_roles_id, user_roles.user_id AS user_roles_user_id, user_roles.role_id AS user_roles_role_id, user_roles.assigned_by AS user_roles_assigned_by, user_roles.assigned_at AS user_roles_assigned_at, user_roles.expires_at AS user_roles_expires_at, user_roles.is_active AS user_roles_is_active 
FROM user_roles 
WHERE ? = user_roles.user_id]
[parameters: (1,)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FAILED tests/test_recommendations.py::test_get_recommended_timeline - assert 500 == 200
 +  where 500 = <WrapperTestResponse streamed [500 INTERNAL SERVER ERROR]>.status_code
FAILED tests/test_recommendations.py::test_recommended_timeline_with_filters - AssertionError: Expected SQL query fragments with correct parameters were not found. Queries executed: ['SELECT COUNT(*) FROM recommendations WHERE user_id = ?', '\n                    SELECT r.post_id, r.score, r.reason, p.content, p.author_id, p.created_at, p.metadata\n                    FROM recommendations r\n                    JOIN posts p ON r.post_id = p.post_id\n                    WHERE r.user_id = ?\n                    ORDER BY r.score DESC\n                    LIMIT ?\n                ']
assert False
FAILED tests/test_recommendations.py::test_recommended_timeline_parameter_validation - assert 200 == 400
 +  where 200 = <WrapperTestResponse streamed [200 OK]>.status_code
FAILED tests/test_recommendations.py::test_recommended_timeline_auto_generate - AssertionError: assert False
 +  where False = <MagicMock name='generate_rankings_for_user' id='6090039920'>.called
FAILED tests/test_scoring_exact.py::test_get_author_preference_score_exact - assert False
 +  where False = <built-in function isclose>(0.1, 0.9241418199787566, rel_tol=1e-06)
 +    where <built-in function isclose> = math.isclose
FAILED tests/test_scoring_exact.py::test_get_recency_score_exact - ImportError: cannot import name 'ALGORITHM_CONFIG' from '<unknown module name>' (unknown location)
========== 35 failed, 374 passed, 17 skipped, 135 warnings in 29.92s ===========
